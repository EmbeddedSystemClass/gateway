ARM GAS  /tmp/ccjG3mld.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.syntax unified
  17              		.file	"SerialTaskReceive.c"
  18              		.text
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.section	.text.advancebuf,"ax",%progbits
  22              		.align	2
  23              		.thumb
  24              		.thumb_func
  26              	advancebuf:
  27              	.LFB133:
  28              		.file 1 "Ourwares/SerialTaskReceive.c"
   1:Ourwares/SerialTaskReceive.c **** /******************************************************************************
   2:Ourwares/SerialTaskReceive.c **** * File Name          : SerialTaskReceive.c
   3:Ourwares/SerialTaskReceive.c **** * Date First Issued  : 01/21/2019
   4:Ourwares/SerialTaskReceive.c **** * Description        : Serial input using FreeRTOS/ST HAL
   5:Ourwares/SerialTaskReceive.c **** *******************************************************************************/
   6:Ourwares/SerialTaskReceive.c **** 
   7:Ourwares/SerialTaskReceive.c **** #include "FreeRTOS.h"
   8:Ourwares/SerialTaskReceive.c **** #include "task.h"
   9:Ourwares/SerialTaskReceive.c **** #include "queue.h"
  10:Ourwares/SerialTaskReceive.c **** #include "cmsis_os.h"
  11:Ourwares/SerialTaskReceive.c **** #include "malloc.h"
  12:Ourwares/SerialTaskReceive.c **** 
  13:Ourwares/SerialTaskReceive.c **** #include "SerialTaskReceive.h"
  14:Ourwares/SerialTaskReceive.c **** 
  15:Ourwares/SerialTaskReceive.c **** #include "stm32f4xx_hal_usart.h"
  16:Ourwares/SerialTaskReceive.c **** #include "stm32f4xx_hal_uart.h"
  17:Ourwares/SerialTaskReceive.c **** 
  18:Ourwares/SerialTaskReceive.c **** #include "gateway_PCtoCAN.h"
  19:Ourwares/SerialTaskReceive.c **** 
  20:Ourwares/SerialTaskReceive.c **** /*
  21:Ourwares/SerialTaskReceive.c **** BaseType_t Rret; // Return value
  22:Ourwares/SerialTaskReceive.c **** ...
  23:Ourwares/SerialTaskReceive.c **** // Initialization before schedular start
  24:Ourwares/SerialTaskReceive.c **** ...
  25:Ourwares/SerialTaskReceive.c **** // uart handle, and dma flag
  26:Ourwares/SerialTaskReceive.c **** Rret = xSerialTaskReceiveAdd(&huart6, 1);
  27:Ourwares/SerialTaskReceive.c **** if (Rret != 0) while(1==1); // Hang
  28:Ourwares/SerialTaskReceive.c **** ...
  29:Ourwares/SerialTaskReceive.c **** // Task initialization, before endless loop
  30:Ourwares/SerialTaskReceive.c **** ...
ARM GAS  /tmp/ccjG3mld.s 			page 2


  31:Ourwares/SerialTaskReceive.c **** // uart handle, number line buffers, size of line buffers (not including \0)
  32:Ourwares/SerialTaskReceive.c **** #define NOTEBIT 0x1;	// Unique bit in this task for this buffer notification
  33:Ourwares/SerialTaskReceive.c **** uint32_t noteval = 0;	// OS copies its notification word upon a "notify"
  34:Ourwares/SerialTaskReceive.c **** // uart handle, dma flag, buffer notify bit, number line buffers, size of line buffers);
  35:Ourwares/SerialTaskReceive.c **** struct SERIALTASKRCVBCB* pinbuf1 = getserialinbuf(&huart6,1, NOTEBIT,&noteval,10,32); 
  36:Ourwares/SerialTaskReceive.c **** ...other getserialinbuf(...) if more than one...
  37:Ourwares/SerialTaskReceive.c **** 
  38:Ourwares/SerialTaskReceive.c **** ...
  39:Ourwares/SerialTaskReceive.c **** for ( ;; )
  40:Ourwares/SerialTaskReceive.c **** {
  41:Ourwares/SerialTaskReceive.c **** ...
  42:Ourwares/SerialTaskReceive.c **** yscanf(pinbuf1," ...",...);
  43:Ourwares/SerialTaskReceive.c **** ...
  44:Ourwares/SerialTaskReceive.c **** }
  45:Ourwares/SerialTaskReceive.c **** 
  46:Ourwares/SerialTaskReceive.c **** */
  47:Ourwares/SerialTaskReceive.c **** 
  48:Ourwares/SerialTaskReceive.c **** static void unloaddma(struct SERIALRCVBCB* prbcb);
  49:Ourwares/SerialTaskReceive.c **** 
  50:Ourwares/SerialTaskReceive.c **** osThreadId SerialTaskReceiveHandle = NULL;
  51:Ourwares/SerialTaskReceive.c **** 
  52:Ourwares/SerialTaskReceive.c **** /* THE FOLLOWING COPIED FOR REFERENCE--
  53:Ourwares/SerialTaskReceive.c **** // Line buffer control block for one uart 
  54:Ourwares/SerialTaskReceive.c **** struct SERIALRCVBCB
  55:Ourwares/SerialTaskReceive.c **** {
  56:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* pnext;	// Link to next uart RBCB
  57:Ourwares/SerialTaskReceive.c **** 	char* pbegin;// Ptr to first line buffer
  58:Ourwares/SerialTaskReceive.c **** 	char* pend;  // Ptr to last+1 line buffer
  59:Ourwares/SerialTaskReceive.c **** 	char* padd;  // Ptr to line buffer being filled
  60:Ourwares/SerialTaskReceive.c **** 	char* ptake; // Ptr to line buffer to take
  61:Ourwares/SerialTaskReceive.c **** 	char* pwork; // Ptr to next char to be added
  62:Ourwares/SerialTaskReceive.c **** 	char* pworkend; // Ptr to end of current active line buffer
  63:Ourwares/SerialTaskReceive.c **** 	UART_HandleTypeDef* phuart;// Pointer to 'MX uart handle
  64:Ourwares/SerialTaskReceive.c **** 	osThreadId tskhandle;      // Task handle of originating task
  65:Ourwares/SerialTaskReceive.c **** 	uint32_t  notebit;         // Unique notification bit (within task)
  66:Ourwares/SerialTaskReceive.c **** 	uint32_t* pnoteval;        // Pointer to word receiving notification 
  67:Ourwares/SerialTaskReceive.c **** 	char*  pbegindma;          // Pointer to beginning of dma buffer
  68:Ourwares/SerialTaskReceive.c **** 	char*  penddma;            // Pointer to ebd + 1 of dma buffer
  69:Ourwares/SerialTaskReceive.c **** 	char*  ptakedma;           // Pointer to last + 1 char taken from dma buffer
  70:Ourwares/SerialTaskReceive.c **** 	uint32_t  numlinexsize;    // Number of lines * line size (chars)
  71:Ourwares/SerialTaskReceive.c **** 	uint16_t  linesize;        // Number of chars in each line buffer (1)
  72:Ourwares/SerialTaskReceive.c **** 	uint16_t  dmasize;         // Number of chars in total circular DMA buffer
  73:Ourwares/SerialTaskReceive.c **** 	uint8_t   numline;         // Number of line (or CAN msg) buffers for this uart
  74:Ourwares/SerialTaskReceive.c **** 	int8_t    dmaflag;         // dmaflag = 0 for char-by-char mode; 1 = dma mode (1)
  75:Ourwares/SerialTaskReceive.c **** 	uint8_t   CANmode;         // 0 = ordinary lines; 1 = ascii/hex CAN
  76:Ourwares/SerialTaskReceive.c **** 	struct GATEWAYPCTOCAN* pgptc; // Pointer to gateway_PCtoCAN control block
  77:Ourwares/SerialTaskReceive.c **** 	uint32_t errorct;				// uart error callback counter
  78:Ourwares/SerialTaskReceive.c **** };
  79:Ourwares/SerialTaskReceive.c **** 
  80:Ourwares/SerialTaskReceive.c **** */
  81:Ourwares/SerialTaskReceive.c **** 
  82:Ourwares/SerialTaskReceive.c **** /* Pointer to linked list of Receive Buffer Control Blocks */
  83:Ourwares/SerialTaskReceive.c **** // Initial is NULL; pnext in last points to last
  84:Ourwares/SerialTaskReceive.c **** static struct SERIALRCVBCB* prbhd = NULL;
  85:Ourwares/SerialTaskReceive.c **** 
  86:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
  87:Ourwares/SerialTaskReceive.c ****  * struct SERIALRCVBCB* xSerialTaskRxAdduart(\
ARM GAS  /tmp/ccjG3mld.s 			page 3


  88:Ourwares/SerialTaskReceive.c **** 		UART_HandleTypeDef* phuart,\
  89:Ourwares/SerialTaskReceive.c **** 		int8_t    dmaflag,\
  90:Ourwares/SerialTaskReceive.c **** 		uint32_t  notebit,\
  91:Ourwares/SerialTaskReceive.c **** 		uint32_t* pnoteval,\
  92:Ourwares/SerialTaskReceive.c **** 		uint8_t   numline,\
  93:Ourwares/SerialTaskReceive.c **** 		uint8_t   linesize,\
  94:Ourwares/SerialTaskReceive.c **** 		char  dmasize,\
  95:Ourwares/SerialTaskReceive.c **** 		uint8_t   CANmode);
  96:Ourwares/SerialTaskReceive.c ****  *	@brief	: Setup circular line buffers this uart
  97:Ourwares/SerialTaskReceive.c ****  * @param	: phuart = pointer to uart control block
  98:Ourwares/SerialTaskReceive.c ****  * @param	: dmaflag = 0 for char-by-char mode; 1 = dma mode
  99:Ourwares/SerialTaskReceive.c ****  * @param	: notebit = unique bit for notification for this task
 100:Ourwares/SerialTaskReceive.c ****  * @param	: pnoteval = pointer to word receiving notification word from OS
 101:Ourwares/SerialTaskReceive.c ****  * @param	: numline = number of line buffers in circular line buffer
 102:Ourwares/SerialTaskReceive.c ****  * @param	: linesize = number of chars in each line buffer
 103:Ourwares/SerialTaskReceive.c ****  * @param	: dmasize = number of chars in total circular DMA buffer
 104:Ourwares/SerialTaskReceive.c ****  * @param	: CANmode = 0 = straight ascii lines; 1 = convert ascii to CAN msgs
 105:Ourwares/SerialTaskReceive.c ****  * @return	: pointer = 'RCVBCB for this uart; NULL = failed
 106:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 107:Ourwares/SerialTaskReceive.c **** struct SERIALRCVBCB* xSerialTaskRxAdduart(\
 108:Ourwares/SerialTaskReceive.c **** 		UART_HandleTypeDef* phuart,\
 109:Ourwares/SerialTaskReceive.c **** 		int8_t    dmaflag,\
 110:Ourwares/SerialTaskReceive.c **** 		uint32_t  notebit,\
 111:Ourwares/SerialTaskReceive.c **** 		uint32_t* pnoteval,\
 112:Ourwares/SerialTaskReceive.c **** 		uint8_t   numline,\
 113:Ourwares/SerialTaskReceive.c **** 		uint8_t   linesize,\
 114:Ourwares/SerialTaskReceive.c **** 		char  dmasize,\
 115:Ourwares/SerialTaskReceive.c **** 		uint8_t   CANmode)
 116:Ourwares/SerialTaskReceive.c **** {
 117:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* ptmp1;
 118:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* ptmp2;
 119:Ourwares/SerialTaskReceive.c **** 	char* pbuf;
 120:Ourwares/SerialTaskReceive.c **** 
 121:Ourwares/SerialTaskReceive.c **** HAL_StatusTypeDef halret;
 122:Ourwares/SerialTaskReceive.c **** 
 123:Ourwares/SerialTaskReceive.c **** 	struct GATEWAYPCTOCAN* pgptc; // Pointer to Gateway Pc To Can
 124:Ourwares/SerialTaskReceive.c **** 
 125:Ourwares/SerialTaskReceive.c **** 	/* There can be a problem with Tasks not started if the calling task gets here first */
 126:Ourwares/SerialTaskReceive.c **** 	osDelay(10);
 127:Ourwares/SerialTaskReceive.c **** 
 128:Ourwares/SerialTaskReceive.c **** taskENTER_CRITICAL();
 129:Ourwares/SerialTaskReceive.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 130:Ourwares/SerialTaskReceive.c **** 	ptmp1 = (struct SERIALRCVBCB*)calloc(1, sizeof(struct SERIALRCVBCB));
 131:Ourwares/SerialTaskReceive.c **** 	if (ptmp1  == NULL) {taskEXIT_CRITICAL();return NULL;}
 132:Ourwares/SerialTaskReceive.c **** 	if (prbhd  == NULL) // Is this the first?
 133:Ourwares/SerialTaskReceive.c **** 	{ // Yes.  
 134:Ourwares/SerialTaskReceive.c **** 		prbhd = ptmp1;	// Point head to first on list
 135:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Point first (and last) item on list to self
 136:Ourwares/SerialTaskReceive.c **** 	}
 137:Ourwares/SerialTaskReceive.c **** 	else
 138:Ourwares/SerialTaskReceive.c **** 	{ // No. One or more have been added
 139:Ourwares/SerialTaskReceive.c **** 		/* Find end of list */
 140:Ourwares/SerialTaskReceive.c **** 		ptmp2 = prbhd;	// Start at head
 141:Ourwares/SerialTaskReceive.c **** 		while (ptmp2 != ptmp2->pnext) ptmp2 = ptmp2->pnext;
 142:Ourwares/SerialTaskReceive.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 143:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Added (and last) lock points to self
 144:Ourwares/SerialTaskReceive.c **** 	}
ARM GAS  /tmp/ccjG3mld.s 			page 4


 145:Ourwares/SerialTaskReceive.c **** 
 146:Ourwares/SerialTaskReceive.c **** 	/* CAN msg conversion depends on line buffer size being large enough for CAN msg. */
 147:Ourwares/SerialTaskReceive.c **** 	if ((CANmode != 0) && (linesize < sizeof(struct CANRCVBUFPLUS))) 
 148:Ourwares/SerialTaskReceive.c **** 	     linesize = sizeof(struct CANRCVBUFPLUS);
 149:Ourwares/SerialTaskReceive.c **** 
 150:Ourwares/SerialTaskReceive.c **** 	/* Get memory for an array of line buffers for this uart */	
 151:Ourwares/SerialTaskReceive.c **** 	pbuf = (char*)calloc(numline*linesize, sizeof(char));
 152:Ourwares/SerialTaskReceive.c **** 	if ( pbuf == NULL) {taskEXIT_CRITICAL();return NULL;}
 153:Ourwares/SerialTaskReceive.c **** 
 154:Ourwares/SerialTaskReceive.c **** 	/* Save parameters */
 155:Ourwares/SerialTaskReceive.c **** 	// ptmp1 points to last item on list
 156:Ourwares/SerialTaskReceive.c **** 	ptmp1->numlinexsize = numline*linesize;
 157:Ourwares/SerialTaskReceive.c **** 	ptmp1->linesize  = linesize;
 158:Ourwares/SerialTaskReceive.c **** 	ptmp1->numline   = numline;
 159:Ourwares/SerialTaskReceive.c **** 	ptmp1->dmaflag   = dmaflag;
 160:Ourwares/SerialTaskReceive.c **** 	ptmp1->pnoteval  = pnoteval;
 161:Ourwares/SerialTaskReceive.c **** 	ptmp1->notebit   = notebit;
 162:Ourwares/SerialTaskReceive.c **** 	ptmp1->phuart    = phuart;
 163:Ourwares/SerialTaskReceive.c **** 	ptmp1->tskhandle = xTaskGetCurrentTaskHandle();
 164:Ourwares/SerialTaskReceive.c **** 	ptmp1->errorct   = 0;
 165:Ourwares/SerialTaskReceive.c **** 
 166:Ourwares/SerialTaskReceive.c **** 	/* Initialize line buffer pointers */
 167:Ourwares/SerialTaskReceive.c **** 	ptmp1->pbegin = pbuf; // First line buffer beginning
 168:Ourwares/SerialTaskReceive.c **** 	ptmp1->padd   = pbuf; // Pointer to where next line will be added
 169:Ourwares/SerialTaskReceive.c **** 	ptmp1->ptake  = pbuf; // Pointer to where next line will be taken
 170:Ourwares/SerialTaskReceive.c **** 	ptmp1->pwork  = pbuf; // Pointer where next char in active line will be added
 171:Ourwares/SerialTaskReceive.c **** 	ptmp1->pworkend = pbuf + linesize - 2; // End of 1st LINE buffer (allow for zero terminator)
 172:Ourwares/SerialTaskReceive.c **** 	ptmp1->pend = pbuf + numline*linesize; // End of line buffers + 1 line
 173:Ourwares/SerialTaskReceive.c **** 	ptmp1->CANmode = CANmode;
 174:Ourwares/SerialTaskReceive.c **** 
 175:Ourwares/SerialTaskReceive.c **** 	if (dmaflag != 0)
 176:Ourwares/SerialTaskReceive.c **** 	{ // Circular DMA buffer 
 177:Ourwares/SerialTaskReceive.c **** 		pbuf = (char*)calloc((int)dmasize, sizeof(char));
 178:Ourwares/SerialTaskReceive.c **** 		if ( pbuf == NULL) return NULL;
 179:Ourwares/SerialTaskReceive.c **** 		ptmp1->pbegindma = pbuf;   // Pointer to beginning of DMA circular buffer
 180:Ourwares/SerialTaskReceive.c **** 		ptmp1->penddma   = pbuf + dmasize; // Pointer to end + 1
 181:Ourwares/SerialTaskReceive.c **** 		ptmp1->ptakedma  = pbuf;   // "Take" Pointer into DMA buffer
 182:Ourwares/SerialTaskReceive.c **** 		ptmp1->dmasize   = dmasize; // Total number of chars in DMA buffer
 183:Ourwares/SerialTaskReceive.c **** 
 184:Ourwares/SerialTaskReceive.c **** 		/* When CANmode is requested, the conversion control block is used */
 185:Ourwares/SerialTaskReceive.c **** 		if (CANmode == 1)
 186:Ourwares/SerialTaskReceive.c **** 		{ // Initialize CAN conversion control block
 187:Ourwares/SerialTaskReceive.c **** 			pgptc = gateway_PCtoCAN_init(ptmp1);
 188:Ourwares/SerialTaskReceive.c **** 			if (pgptc == NULL)  {taskEXIT_CRITICAL();return NULL;}
 189:Ourwares/SerialTaskReceive.c **** 			ptmp1->pgptc = pgptc; // Save pointer to CAN conversion control block
 190:Ourwares/SerialTaskReceive.c **** 		}
 191:Ourwares/SerialTaskReceive.c **** 
 192:Ourwares/SerialTaskReceive.c **** 		/* Start uart-dma circular mode.  Start once; run forever. */
 193:Ourwares/SerialTaskReceive.c **** 		halret = HAL_UART_Receive_DMA(ptmp1->phuart, (uint8_t*)ptmp1->pbegindma, ptmp1->dmasize);
 194:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 195:Ourwares/SerialTaskReceive.c **** 		{
 196:Ourwares/SerialTaskReceive.c **** 			taskEXIT_CRITICAL();
 197:Ourwares/SerialTaskReceive.c **** 			return NULL;
 198:Ourwares/SerialTaskReceive.c **** 		}
 199:Ourwares/SerialTaskReceive.c **** 	}
 200:Ourwares/SerialTaskReceive.c **** 	else
 201:Ourwares/SerialTaskReceive.c **** 	{ // Start char-by-char mode. Restart upon each interrupt.
ARM GAS  /tmp/ccjG3mld.s 			page 5


 202:Ourwares/SerialTaskReceive.c **** 		halret = HAL_UART_Receive_IT(ptmp1->phuart, (uint8_t*)ptmp1->pwork, 1);
 203:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 204:Ourwares/SerialTaskReceive.c **** 		{
 205:Ourwares/SerialTaskReceive.c **** 			taskEXIT_CRITICAL();
 206:Ourwares/SerialTaskReceive.c **** 			return NULL;
 207:Ourwares/SerialTaskReceive.c **** 		}
 208:Ourwares/SerialTaskReceive.c **** 	}
 209:Ourwares/SerialTaskReceive.c **** taskEXIT_CRITICAL();
 210:Ourwares/SerialTaskReceive.c **** 	return ptmp1;	// Success return pointer to this 'BCB
 211:Ourwares/SerialTaskReceive.c **** }
 212:Ourwares/SerialTaskReceive.c **** 
 213:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 214:Ourwares/SerialTaskReceive.c ****  * void StartSerialTaskReceive(void* argument);
 215:Ourwares/SerialTaskReceive.c ****  *	@brief	: Task startup
 216:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 217:Ourwares/SerialTaskReceive.c **** void StartSerialTaskReceive(void* argument)
 218:Ourwares/SerialTaskReceive.c **** {
 219:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 220:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp2;
 221:Ourwares/SerialTaskReceive.c **** 	
 222:Ourwares/SerialTaskReceive.c **** 	/* Do nothing until at least one tasks calls 
 223:Ourwares/SerialTaskReceive.c ****       'xSerialTaskRxAdduart' and sets up the 
 224:Ourwares/SerialTaskReceive.c ****        uart and buffering. */
 225:Ourwares/SerialTaskReceive.c **** 
 226:Ourwares/SerialTaskReceive.c **** 	while (prtmp == NULL)
 227:Ourwares/SerialTaskReceive.c **** 	{
 228:Ourwares/SerialTaskReceive.c **** 		osDelay(10);
 229:Ourwares/SerialTaskReceive.c **** 		prtmp = prbhd;
 230:Ourwares/SerialTaskReceive.c **** 	}
 231:Ourwares/SerialTaskReceive.c **** 
 232:Ourwares/SerialTaskReceive.c ****   /* Infinite loop */
 233:Ourwares/SerialTaskReceive.c ****   for(;;)
 234:Ourwares/SerialTaskReceive.c ****   {
 235:Ourwares/SerialTaskReceive.c **** 		/* Wait for one tick or notification from a dma callback */
 236:Ourwares/SerialTaskReceive.c **** 		xTaskNotifyWait(0, 0, NULL, 2);
 237:Ourwares/SerialTaskReceive.c **** 
 238:Ourwares/SerialTaskReceive.c **** 		/* Go through list of receiving uarts and unload only dma uart buffers. */
 239:Ourwares/SerialTaskReceive.c **** 		prtmp = prbhd;
 240:Ourwares/SerialTaskReceive.c **** 		do
 241:Ourwares/SerialTaskReceive.c **** 		{
 242:Ourwares/SerialTaskReceive.c **** 			if (prtmp->dmaflag != 0)
 243:Ourwares/SerialTaskReceive.c **** 			{ // Here, dma mode
 244:Ourwares/SerialTaskReceive.c **** 				if (prtmp->CANmode == 1)
 245:Ourwares/SerialTaskReceive.c **** 				{ // Here, convert to CAN msg buffers
 246:Ourwares/SerialTaskReceive.c **** 					gateway_PCtoCAN_unloaddma(prtmp);
 247:Ourwares/SerialTaskReceive.c **** 				}
 248:Ourwares/SerialTaskReceive.c **** 				else
 249:Ourwares/SerialTaskReceive.c **** 				{ // Here, straight ascii line buffers
 250:Ourwares/SerialTaskReceive.c **** 					unloaddma(prtmp);
 251:Ourwares/SerialTaskReceive.c **** 				}
 252:Ourwares/SerialTaskReceive.c **** 			}
 253:Ourwares/SerialTaskReceive.c **** 			prtmp2 = prtmp;
 254:Ourwares/SerialTaskReceive.c **** 			prtmp = prtmp2->pnext;
 255:Ourwares/SerialTaskReceive.c **** 		} while (prtmp2->pnext != prtmp2);
 256:Ourwares/SerialTaskReceive.c ****   }
 257:Ourwares/SerialTaskReceive.c **** }
 258:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
ARM GAS  /tmp/ccjG3mld.s 			page 6


 259:Ourwares/SerialTaskReceive.c ****  * osThreadId xSerialTaskReceiveCreate(uint32_t taskpriority);
 260:Ourwares/SerialTaskReceive.c ****  * @brief	: Create task; task handle created is global for all to enjoy!
 261:Ourwares/SerialTaskReceive.c ****  * @param	: taskpriority = Task priority (just as it says!)
 262:Ourwares/SerialTaskReceive.c ****  * @return	: SerialTaskReceiveHandle
 263:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 264:Ourwares/SerialTaskReceive.c ****  BaseType_t xSerialTaskReceiveCreate(uint32_t taskpriority)
 265:Ourwares/SerialTaskReceive.c **** {
 266:Ourwares/SerialTaskReceive.c **** /*
 267:Ourwares/SerialTaskReceive.c **** BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
 268:Ourwares/SerialTaskReceive.c **** const char * const pcName,
 269:Ourwares/SerialTaskReceive.c **** unsigned short usStackDepth,
 270:Ourwares/SerialTaskReceive.c **** void *pvParameters,
 271:Ourwares/SerialTaskReceive.c **** UBaseType_t uxPriority,
 272:Ourwares/SerialTaskReceive.c **** TaskHandle_t *pxCreatedTask );
 273:Ourwares/SerialTaskReceive.c **** */
 274:Ourwares/SerialTaskReceive.c **** 	return xTaskCreate(StartSerialTaskReceive, "StartSerialTaskReceive",\
 275:Ourwares/SerialTaskReceive.c ****      96, NULL, taskpriority,\
 276:Ourwares/SerialTaskReceive.c ****      &SerialTaskReceiveHandle);
 277:Ourwares/SerialTaskReceive.c **** }
 278:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 279:Ourwares/SerialTaskReceive.c ****  * char* xSerialTaskReceiveGetline(struct SERIALRCVBCB* pbcb);
 280:Ourwares/SerialTaskReceive.c ****  *	@brief	: Load buffer control block onto queue for sending
 281:Ourwares/SerialTaskReceive.c ****  * @param	: pbcb = Pointer to Buffer Control Block
 282:Ourwares/SerialTaskReceive.c ****  * @return	: Pointer to line buffer; NULL = no new lines
 283:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 284:Ourwares/SerialTaskReceive.c **** char* xSerialTaskReceiveGetline(struct SERIALRCVBCB* pbcb)
 285:Ourwares/SerialTaskReceive.c **** {
 286:Ourwares/SerialTaskReceive.c **** 	char* p = NULL;
 287:Ourwares/SerialTaskReceive.c **** 
 288:Ourwares/SerialTaskReceive.c **** 	/* Check no new lines. */
 289:Ourwares/SerialTaskReceive.c **** 	if (pbcb->ptake == pbcb->padd) return p;
 290:Ourwares/SerialTaskReceive.c **** 	p = pbcb->ptake;
 291:Ourwares/SerialTaskReceive.c **** 
 292:Ourwares/SerialTaskReceive.c **** 	/* Advance 'take' pointer w wraparound check. */
 293:Ourwares/SerialTaskReceive.c **** 	pbcb->ptake += pbcb->linesize;
 294:Ourwares/SerialTaskReceive.c **** 	if (pbcb->ptake >= pbcb->pend) pbcb->ptake = pbcb->pbegin;
 295:Ourwares/SerialTaskReceive.c **** 
 296:Ourwares/SerialTaskReceive.c **** 	return p;
 297:Ourwares/SerialTaskReceive.c **** }
 298:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 299:Ourwares/SerialTaskReceive.c ****  * static void advancebuf(struct SERIALRCVBCB* prtmp);
 300:Ourwares/SerialTaskReceive.c ****  * @brief	: Advance to next line buffer
 301:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 302:Ourwares/SerialTaskReceive.c **** static void advancebuf(struct SERIALRCVBCB* prtmp)
 303:Ourwares/SerialTaskReceive.c **** {		
  29              		.loc 1 303 0
  30              		.cfi_startproc
  31              		@ args = 0, pretend = 0, frame = 8
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              	.LVL0:
  34 0000 00B5     		push	{lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 4
  37              		.cfi_offset 14, -4
  38 0002 85B0     		sub	sp, sp, #20
  39              	.LCFI1:
  40              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccjG3mld.s 			page 7


 304:Ourwares/SerialTaskReceive.c **** 	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  41              		.loc 1 304 0
  42 0004 0023     		movs	r3, #0
  43 0006 0393     		str	r3, [sp, #12]
 305:Ourwares/SerialTaskReceive.c **** 
 306:Ourwares/SerialTaskReceive.c **** 	/* Zero terminator addition. */
 307:Ourwares/SerialTaskReceive.c **** 	*prtmp->pwork = 0; // Add string terminator
  44              		.loc 1 307 0
  45 0008 4269     		ldr	r2, [r0, #20]
  46 000a 1370     		strb	r3, [r2]
 308:Ourwares/SerialTaskReceive.c **** 	
 309:Ourwares/SerialTaskReceive.c **** 	/* Advance to beginning of next line buffer */
 310:Ourwares/SerialTaskReceive.c **** 	prtmp->padd += prtmp->linesize;	// Step ahead one buffer length
  47              		.loc 1 310 0
  48 000c 838F     		ldrh	r3, [r0, #60]
  49 000e C268     		ldr	r2, [r0, #12]
  50 0010 1A44     		add	r2, r2, r3
  51 0012 C260     		str	r2, [r0, #12]
 311:Ourwares/SerialTaskReceive.c **** 	if (prtmp->padd == prtmp->pend) prtmp->padd = prtmp->pbegin;
  52              		.loc 1 311 0
  53 0014 8168     		ldr	r1, [r0, #8]
  54 0016 8A42     		cmp	r2, r1
  55 0018 01D1     		bne	.L2
  56              		.loc 1 311 0 is_stmt 0 discriminator 1
  57 001a 4268     		ldr	r2, [r0, #4]
  58 001c C260     		str	r2, [r0, #12]
  59              	.L2:
 312:Ourwares/SerialTaskReceive.c **** 
 313:Ourwares/SerialTaskReceive.c **** 	/* Initialize working char pointers */
 314:Ourwares/SerialTaskReceive.c **** 	prtmp->pwork = prtmp->padd;	// Begin
  60              		.loc 1 314 0 is_stmt 1
  61 001e C268     		ldr	r2, [r0, #12]
  62 0020 4261     		str	r2, [r0, #20]
 315:Ourwares/SerialTaskReceive.c **** 	prtmp->pworkend = prtmp->padd + prtmp->linesize - 2; // End
  63              		.loc 1 315 0
  64 0022 023B     		subs	r3, r3, #2
  65 0024 1344     		add	r3, r3, r2
  66 0026 8361     		str	r3, [r0, #24]
 316:Ourwares/SerialTaskReceive.c **** 
 317:Ourwares/SerialTaskReceive.c **** 	/* Notify originating task know a line is ready. */
 318:Ourwares/SerialTaskReceive.c **** 	xTaskNotifyFromISR(prtmp->tskhandle, 
  67              		.loc 1 318 0
  68 0028 416A     		ldr	r1, [r0, #36]
  69 002a 006A     		ldr	r0, [r0, #32]
  70              	.LVL1:
  71 002c 03AB     		add	r3, sp, #12
  72 002e 0093     		str	r3, [sp]
  73 0030 0023     		movs	r3, #0
  74 0032 0122     		movs	r2, #1
  75 0034 FFF7FEFF 		bl	xTaskGenericNotifyFromISR
  76              	.LVL2:
 319:Ourwares/SerialTaskReceive.c **** 		prtmp->notebit,	/* 'or' bit assigned to buffer to notification value. */
 320:Ourwares/SerialTaskReceive.c **** 		eSetBits,      /* Set 'or' option */
 321:Ourwares/SerialTaskReceive.c **** 		&xHigherPriorityTaskWoken );
 322:Ourwares/SerialTaskReceive.c **** 
 323:Ourwares/SerialTaskReceive.c **** 	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
  77              		.loc 1 323 0
ARM GAS  /tmp/ccjG3mld.s 			page 8


  78 0038 039B     		ldr	r3, [sp, #12]
  79 003a 3BB1     		cbz	r3, .L1
  80              		.loc 1 323 0 is_stmt 0 discriminator 1
  81 003c 4FF08052 		mov	r2, #268435456
  82 0040 044B     		ldr	r3, .L5
  83 0042 1A60     		str	r2, [r3]
  84              		.syntax unified
  85              	@ 323 "Ourwares/SerialTaskReceive.c" 1
  86 0044 BFF34F8F 		dsb
  87              	@ 0 "" 2
  88              	@ 323 "Ourwares/SerialTaskReceive.c" 1
  89 0048 BFF36F8F 		isb
  90              	@ 0 "" 2
  91              		.thumb
  92              		.syntax unified
  93              	.L1:
 324:Ourwares/SerialTaskReceive.c **** 	return;
 325:Ourwares/SerialTaskReceive.c **** }
  94              		.loc 1 325 0 is_stmt 1
  95 004c 05B0     		add	sp, sp, #20
  96              	.LCFI2:
  97              		.cfi_def_cfa_offset 4
  98              		@ sp needed
  99 004e 5DF804FB 		ldr	pc, [sp], #4
 100              	.L6:
 101 0052 00BF     		.align	2
 102              	.L5:
 103 0054 04ED00E0 		.word	-536810236
 104              		.cfi_endproc
 105              	.LFE133:
 107              		.section	.text.advanceptr,"ax",%progbits
 108              		.align	2
 109              		.thumb
 110              		.thumb_func
 112              	advanceptr:
 113              	.LFB134:
 326:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 327:Ourwares/SerialTaskReceive.c ****  * static void advanceptr(struct SERIALRCVBCB* prtmp);
 328:Ourwares/SerialTaskReceive.c ****  * @brief	: Advance pointer within the active line buffer
 329:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 330:Ourwares/SerialTaskReceive.c **** static void advanceptr(struct SERIALRCVBCB* prtmp, char c)
 331:Ourwares/SerialTaskReceive.c **** {
 114              		.loc 1 331 0
 115              		.cfi_startproc
 116              		@ args = 0, pretend = 0, frame = 0
 117              		@ frame_needed = 0, uses_anonymous_args = 0
 118              	.LVL3:
 119 0000 08B5     		push	{r3, lr}
 120              	.LCFI3:
 121              		.cfi_def_cfa_offset 8
 122              		.cfi_offset 3, -8
 123              		.cfi_offset 14, -4
 332:Ourwares/SerialTaskReceive.c **** 	*prtmp->pwork++ = c;
 124              		.loc 1 332 0
 125 0002 4369     		ldr	r3, [r0, #20]
 126 0004 5A1C     		adds	r2, r3, #1
 127 0006 4261     		str	r2, [r0, #20]
ARM GAS  /tmp/ccjG3mld.s 			page 9


 128 0008 1970     		strb	r1, [r3]
 333:Ourwares/SerialTaskReceive.c **** 	if ((c == LINETERMINATOR) || (c == 0XD))
 129              		.loc 1 333 0
 130 000a 0A29     		cmp	r1, #10
 131 000c 01D0     		beq	.L8
 132              		.loc 1 333 0 is_stmt 0 discriminator 1
 133 000e 0D29     		cmp	r1, #13
 134 0010 02D1     		bne	.L9
 135              	.L8:
 334:Ourwares/SerialTaskReceive.c **** 	{ // Here End of Line
 335:Ourwares/SerialTaskReceive.c **** 		advancebuf(prtmp); // Advance to new line buffer and notify originator
 136              		.loc 1 335 0 is_stmt 1
 137 0012 FFF7FEFF 		bl	advancebuf
 138              	.LVL4:
 336:Ourwares/SerialTaskReceive.c **** 		return;
 139              		.loc 1 336 0
 140 0016 08BD     		pop	{r3, pc}
 141              	.LVL5:
 142              	.L9:
 337:Ourwares/SerialTaskReceive.c **** 	}
 338:Ourwares/SerialTaskReceive.c **** 
 339:Ourwares/SerialTaskReceive.c **** 	/* Here, just an ordinary char stored. */
 340:Ourwares/SerialTaskReceive.c **** 	if (prtmp->pwork == prtmp->pworkend)
 143              		.loc 1 340 0
 144 0018 4269     		ldr	r2, [r0, #20]
 145 001a 8369     		ldr	r3, [r0, #24]
 146 001c 9A42     		cmp	r2, r3
 147 001e 01D1     		bne	.L7
 341:Ourwares/SerialTaskReceive.c **** 	{ // Here we are at end - 1 of line buffer
 342:Ourwares/SerialTaskReceive.c **** 		advancebuf(prtmp); // Advance to new line buffer and notify originator
 148              		.loc 1 342 0
 149 0020 FFF7FEFF 		bl	advancebuf
 150              	.LVL6:
 151              	.L7:
 152 0024 08BD     		pop	{r3, pc}
 153              		.cfi_endproc
 154              	.LFE134:
 156 0026 00BF     		.section	.text.unloaddma,"ax",%progbits
 157              		.align	2
 158              		.thumb
 159              		.thumb_func
 161              	unloaddma:
 162              	.LFB135:
 343:Ourwares/SerialTaskReceive.c **** 	}	
 344:Ourwares/SerialTaskReceive.c **** 	return;
 345:Ourwares/SerialTaskReceive.c **** }
 346:Ourwares/SerialTaskReceive.c **** 
 347:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 348:Ourwares/SerialTaskReceive.c ****  * static void unloaddma(struct SERIALRCVBCB* prbcb);
 349:Ourwares/SerialTaskReceive.c ****  * @brief	: DMA: Check for line terminator and store; enter from task poll
 350:Ourwares/SerialTaskReceive.c ****  * @param	: prbcb = pointer to buffer control block for uart causing callback
 351:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 352:Ourwares/SerialTaskReceive.c **** static void unloaddma(struct SERIALRCVBCB* prbcb)
 353:Ourwares/SerialTaskReceive.c **** {
 163              		.loc 1 353 0
 164              		.cfi_startproc
 165              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccjG3mld.s 			page 10


 166              		@ frame_needed = 0, uses_anonymous_args = 0
 167              	.LVL7:
 168 0000 38B5     		push	{r3, r4, r5, lr}
 169              	.LCFI4:
 170              		.cfi_def_cfa_offset 16
 171              		.cfi_offset 3, -16
 172              		.cfi_offset 4, -12
 173              		.cfi_offset 5, -8
 174              		.cfi_offset 14, -4
 175 0002 0446     		mov	r4, r0
 354:Ourwares/SerialTaskReceive.c **** 	uint16_t dmandtr;	// Number of data items remaining in DMA NDTR register
 355:Ourwares/SerialTaskReceive.c **** 	int32_t diff;
 356:Ourwares/SerialTaskReceive.c **** 	char c;
 357:Ourwares/SerialTaskReceive.c **** 
 358:Ourwares/SerialTaskReceive.c **** // bsp_uart.c handling of dma
 359:Ourwares/SerialTaskReceive.c **** //		Diff = ( pctl->rxbuff_end - DMA_SNDTR(pctl->idma,pctl->rxdma_stream) - pctl->rxbuff_out );
 360:Ourwares/SerialTaskReceive.c **** //		if (Diff < 0)
 361:Ourwares/SerialTaskReceive.c **** //			Diff += pctl->rxbuff_size;  // Adjust for wrap
 362:Ourwares/SerialTaskReceive.c **** 
 363:Ourwares/SerialTaskReceive.c **** 		/* Get number of data item count in DMA buffer "now" from DMA NDTR register. */
 364:Ourwares/SerialTaskReceive.c **** 		dmandtr = __HAL_DMA_GET_COUNTER(prbcb->phuart->hdmarx); 
 176              		.loc 1 364 0
 177 0004 C369     		ldr	r3, [r0, #28]
 178 0006 5B6B     		ldr	r3, [r3, #52]
 179 0008 1B68     		ldr	r3, [r3]
 180 000a 5D68     		ldr	r5, [r3, #4]
 181              	.LVL8:
 365:Ourwares/SerialTaskReceive.c **** 
 366:Ourwares/SerialTaskReceive.c **** 		/* Difference between where we are taking out chars, and where DMA is or was storing. */
 367:Ourwares/SerialTaskReceive.c **** 		diff = prbcb->penddma - dmandtr - prbcb->ptakedma; 
 182              		.loc 1 367 0
 183 000c 026B     		ldr	r2, [r0, #48]
 184 000e ADB2     		uxth	r5, r5
 185 0010 531B     		subs	r3, r2, r5
 186 0012 456B     		ldr	r5, [r0, #52]
 187              	.LVL9:
 368:Ourwares/SerialTaskReceive.c **** 		if (diff < 0)
 188              		.loc 1 368 0
 189 0014 5D1B     		subs	r5, r3, r5
 190              	.LVL10:
 191 0016 0FD5     		bpl	.L14
 369:Ourwares/SerialTaskReceive.c **** 		{ // Wrap around
 370:Ourwares/SerialTaskReceive.c **** 			diff += prbcb->dmasize;
 192              		.loc 1 370 0
 193 0018 C38F     		ldrh	r3, [r0, #62]
 194 001a 1D44     		add	r5, r5, r3
 195              	.LVL11:
 196 001c 0CE0     		b	.L14
 197              	.LVL12:
 198              	.L16:
 371:Ourwares/SerialTaskReceive.c **** 		}
 372:Ourwares/SerialTaskReceive.c **** 
 373:Ourwares/SerialTaskReceive.c **** 		/* Copy dma circular buffer into buffered lines */
 374:Ourwares/SerialTaskReceive.c **** 		while (diff > 0)
 375:Ourwares/SerialTaskReceive.c **** 		{
 376:Ourwares/SerialTaskReceive.c **** 			diff -= 1;
 199              		.loc 1 376 0
ARM GAS  /tmp/ccjG3mld.s 			page 11


 200 001e 013D     		subs	r5, r5, #1
 201              	.LVL13:
 377:Ourwares/SerialTaskReceive.c **** 			c = *prbcb->ptakedma++; // Get char from dma buffer
 202              		.loc 1 377 0
 203 0020 626B     		ldr	r2, [r4, #52]
 204 0022 531C     		adds	r3, r2, #1
 205 0024 6363     		str	r3, [r4, #52]
 206 0026 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 207              	.LVL14:
 378:Ourwares/SerialTaskReceive.c **** 			if (prbcb->ptakedma == prbcb->penddma) prbcb->ptakedma = prbcb->pbegindma;
 208              		.loc 1 378 0
 209 0028 226B     		ldr	r2, [r4, #48]
 210 002a 9342     		cmp	r3, r2
 211 002c 01D1     		bne	.L15
 212              		.loc 1 378 0 is_stmt 0 discriminator 1
 213 002e E36A     		ldr	r3, [r4, #44]
 214 0030 6363     		str	r3, [r4, #52]
 215              	.L15:
 379:Ourwares/SerialTaskReceive.c **** 			
 380:Ourwares/SerialTaskReceive.c **** 			advanceptr(prbcb,c);
 216              		.loc 1 380 0 is_stmt 1
 217 0032 2046     		mov	r0, r4
 218 0034 FFF7FEFF 		bl	advanceptr
 219              	.LVL15:
 220              	.L14:
 374:Ourwares/SerialTaskReceive.c **** 		{
 221              		.loc 1 374 0
 222 0038 002D     		cmp	r5, #0
 223 003a F0DC     		bgt	.L16
 381:Ourwares/SerialTaskReceive.c **** 		}
 382:Ourwares/SerialTaskReceive.c **** 		return;
 383:Ourwares/SerialTaskReceive.c **** }
 224              		.loc 1 383 0
 225 003c 38BD     		pop	{r3, r4, r5, pc}
 226              		.cfi_endproc
 227              	.LFE135:
 229 003e 00BF     		.section	.text.StartSerialTaskReceive,"ax",%progbits
 230              		.align	2
 231              		.global	StartSerialTaskReceive
 232              		.thumb
 233              		.thumb_func
 235              	StartSerialTaskReceive:
 236              	.LFB130:
 218:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 237              		.loc 1 218 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241              	.LVL16:
 242 0000 10B5     		push	{r4, lr}
 243              	.LCFI5:
 244              		.cfi_def_cfa_offset 8
 245              		.cfi_offset 4, -8
 246              		.cfi_offset 14, -4
 219:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp2;
 247              		.loc 1 219 0
 248 0002 134B     		ldr	r3, .L27
ARM GAS  /tmp/ccjG3mld.s 			page 12


 249 0004 1B68     		ldr	r3, [r3]
 250              	.LVL17:
 226:Ourwares/SerialTaskReceive.c **** 	{
 251              		.loc 1 226 0
 252 0006 04E0     		b	.L19
 253              	.LVL18:
 254              	.L20:
 228:Ourwares/SerialTaskReceive.c **** 		prtmp = prbhd;
 255              		.loc 1 228 0
 256 0008 0A20     		movs	r0, #10
 257 000a FFF7FEFF 		bl	osDelay
 258              	.LVL19:
 229:Ourwares/SerialTaskReceive.c **** 	}
 259              		.loc 1 229 0
 260 000e 104B     		ldr	r3, .L27
 261 0010 1B68     		ldr	r3, [r3]
 262              	.LVL20:
 263              	.L19:
 226:Ourwares/SerialTaskReceive.c **** 	{
 264              		.loc 1 226 0
 265 0012 002B     		cmp	r3, #0
 266 0014 F8D0     		beq	.L20
 267              	.L24:
 236:Ourwares/SerialTaskReceive.c **** 
 268              		.loc 1 236 0
 269 0016 0223     		movs	r3, #2
 270              	.LVL21:
 271 0018 0022     		movs	r2, #0
 272 001a 1146     		mov	r1, r2
 273 001c 1046     		mov	r0, r2
 274 001e FFF7FEFF 		bl	xTaskNotifyWait
 275              	.LVL22:
 239:Ourwares/SerialTaskReceive.c **** 		do
 276              		.loc 1 239 0
 277 0022 0B4B     		ldr	r3, .L27
 278 0024 1C68     		ldr	r4, [r3]
 279              	.LVL23:
 280 0026 00E0     		b	.L23
 281              	.LVL24:
 282              	.L25:
 254:Ourwares/SerialTaskReceive.c **** 		} while (prtmp2->pnext != prtmp2);
 283              		.loc 1 254 0
 284 0028 1C46     		mov	r4, r3
 285              	.LVL25:
 286              	.L23:
 242:Ourwares/SerialTaskReceive.c **** 			{ // Here, dma mode
 287              		.loc 1 242 0
 288 002a 94F94130 		ldrsb	r3, [r4, #65]
 289 002e 53B1     		cbz	r3, .L21
 244:Ourwares/SerialTaskReceive.c **** 				{ // Here, convert to CAN msg buffers
 290              		.loc 1 244 0
 291 0030 94F84230 		ldrb	r3, [r4, #66]	@ zero_extendqisi2
 292 0034 012B     		cmp	r3, #1
 293 0036 03D1     		bne	.L22
 246:Ourwares/SerialTaskReceive.c **** 				}
 294              		.loc 1 246 0
 295 0038 2046     		mov	r0, r4
ARM GAS  /tmp/ccjG3mld.s 			page 13


 296 003a FFF7FEFF 		bl	gateway_PCtoCAN_unloaddma
 297              	.LVL26:
 298 003e 02E0     		b	.L21
 299              	.L22:
 250:Ourwares/SerialTaskReceive.c **** 				}
 300              		.loc 1 250 0
 301 0040 2046     		mov	r0, r4
 302 0042 FFF7FEFF 		bl	unloaddma
 303              	.LVL27:
 304              	.L21:
 254:Ourwares/SerialTaskReceive.c **** 		} while (prtmp2->pnext != prtmp2);
 305              		.loc 1 254 0
 306 0046 2368     		ldr	r3, [r4]
 307              	.LVL28:
 255:Ourwares/SerialTaskReceive.c ****   }
 308              		.loc 1 255 0
 309 0048 9C42     		cmp	r4, r3
 310 004a EDD1     		bne	.L25
 311 004c E3E7     		b	.L24
 312              	.L28:
 313 004e 00BF     		.align	2
 314              	.L27:
 315 0050 00000000 		.word	.LANCHOR0
 316              		.cfi_endproc
 317              	.LFE130:
 319              		.section	.text.xSerialTaskRxAdduart,"ax",%progbits
 320              		.align	2
 321              		.global	xSerialTaskRxAdduart
 322              		.thumb
 323              		.thumb_func
 325              	xSerialTaskRxAdduart:
 326              	.LFB129:
 116:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* ptmp1;
 327              		.loc 1 116 0
 328              		.cfi_startproc
 329              		@ args = 16, pretend = 0, frame = 16
 330              		@ frame_needed = 0, uses_anonymous_args = 0
 331              	.LVL29:
 332 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 333              	.LCFI6:
 334              		.cfi_def_cfa_offset 36
 335              		.cfi_offset 4, -36
 336              		.cfi_offset 5, -32
 337              		.cfi_offset 6, -28
 338              		.cfi_offset 7, -24
 339              		.cfi_offset 8, -20
 340              		.cfi_offset 9, -16
 341              		.cfi_offset 10, -12
 342              		.cfi_offset 11, -8
 343              		.cfi_offset 14, -4
 344 0004 85B0     		sub	sp, sp, #20
 345              	.LCFI7:
 346              		.cfi_def_cfa_offset 56
 347 0006 0190     		str	r0, [sp, #4]
 348 0008 8A46     		mov	r10, r1
 349 000a 0292     		str	r2, [sp, #8]
 350 000c 0393     		str	r3, [sp, #12]
ARM GAS  /tmp/ccjG3mld.s 			page 14


 351 000e 9DF83890 		ldrb	r9, [sp, #56]	@ zero_extendqisi2
 352 0012 9DF83C50 		ldrb	r5, [sp, #60]	@ zero_extendqisi2
 353 0016 9DF840B0 		ldrb	fp, [sp, #64]	@ zero_extendqisi2
 354 001a 9DF84480 		ldrb	r8, [sp, #68]	@ zero_extendqisi2
 126:Ourwares/SerialTaskReceive.c **** 
 355              		.loc 1 126 0
 356 001e 0A20     		movs	r0, #10
 357              	.LVL30:
 358 0020 FFF7FEFF 		bl	osDelay
 359              	.LVL31:
 128:Ourwares/SerialTaskReceive.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 360              		.loc 1 128 0
 361 0024 FFF7FEFF 		bl	vPortEnterCritical
 362              	.LVL32:
 130:Ourwares/SerialTaskReceive.c **** 	if (ptmp1  == NULL) {taskEXIT_CRITICAL();return NULL;}
 363              		.loc 1 130 0
 364 0028 4C21     		movs	r1, #76
 365 002a 0120     		movs	r0, #1
 366 002c FFF7FEFF 		bl	calloc
 367              	.LVL33:
 131:Ourwares/SerialTaskReceive.c **** 	if (prbhd  == NULL) // Is this the first?
 368              		.loc 1 131 0
 369 0030 18B9     		cbnz	r0, .L30
 131:Ourwares/SerialTaskReceive.c **** 	if (prbhd  == NULL) // Is this the first?
 370              		.loc 1 131 0 is_stmt 0 discriminator 1
 371 0032 FFF7FEFF 		bl	vPortExitCritical
 372              	.LVL34:
 373 0036 0020     		movs	r0, #0
 374 0038 71E0     		b	.L31
 375              	.LVL35:
 376              	.L30:
 377 003a 0446     		mov	r4, r0
 132:Ourwares/SerialTaskReceive.c **** 	{ // Yes.  
 378              		.loc 1 132 0 is_stmt 1
 379 003c 394B     		ldr	r3, .L44
 380 003e 1B68     		ldr	r3, [r3]
 381 0040 23B9     		cbnz	r3, .L32
 134:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Point first (and last) item on list to self
 382              		.loc 1 134 0
 383 0042 384B     		ldr	r3, .L44
 384 0044 1860     		str	r0, [r3]
 135:Ourwares/SerialTaskReceive.c **** 	}
 385              		.loc 1 135 0
 386 0046 2060     		str	r0, [r4]
 387 0048 05E0     		b	.L33
 388              	.LVL36:
 389              	.L40:
 141:Ourwares/SerialTaskReceive.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 390              		.loc 1 141 0
 391 004a 1346     		mov	r3, r2
 392              	.LVL37:
 393              	.L32:
 141:Ourwares/SerialTaskReceive.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 394              		.loc 1 141 0 is_stmt 0 discriminator 1
 395 004c 1A68     		ldr	r2, [r3]
 396 004e 9342     		cmp	r3, r2
 397 0050 FBD1     		bne	.L40
ARM GAS  /tmp/ccjG3mld.s 			page 15


 142:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Added (and last) lock points to self
 398              		.loc 1 142 0 is_stmt 1
 399 0052 1C60     		str	r4, [r3]
 143:Ourwares/SerialTaskReceive.c **** 	}
 400              		.loc 1 143 0
 401 0054 2460     		str	r4, [r4]
 402              	.LVL38:
 403              	.L33:
 147:Ourwares/SerialTaskReceive.c **** 	     linesize = sizeof(struct CANRCVBUFPLUS);
 404              		.loc 1 147 0
 405 0056 B8F1000F 		cmp	r8, #0
 406 005a 02D0     		beq	.L34
 147:Ourwares/SerialTaskReceive.c **** 	     linesize = sizeof(struct CANRCVBUFPLUS);
 407              		.loc 1 147 0 is_stmt 0 discriminator 1
 408 005c 172D     		cmp	r5, #23
 409 005e 00D8     		bhi	.L34
 148:Ourwares/SerialTaskReceive.c **** 
 410              		.loc 1 148 0 is_stmt 1
 411 0060 1825     		movs	r5, #24
 412              	.L34:
 413              	.LVL39:
 151:Ourwares/SerialTaskReceive.c **** 	if ( pbuf == NULL) {taskEXIT_CRITICAL();return NULL;}
 414              		.loc 1 151 0
 415 0062 05FB09F7 		mul	r7, r5, r9
 416 0066 0121     		movs	r1, #1
 417 0068 3846     		mov	r0, r7
 418              	.LVL40:
 419 006a FFF7FEFF 		bl	calloc
 420              	.LVL41:
 152:Ourwares/SerialTaskReceive.c **** 
 421              		.loc 1 152 0
 422 006e 0646     		mov	r6, r0
 423 0070 18B9     		cbnz	r0, .L35
 152:Ourwares/SerialTaskReceive.c **** 
 424              		.loc 1 152 0 is_stmt 0 discriminator 1
 425 0072 FFF7FEFF 		bl	vPortExitCritical
 426              	.LVL42:
 427 0076 0020     		movs	r0, #0
 428 0078 51E0     		b	.L31
 429              	.LVL43:
 430              	.L35:
 156:Ourwares/SerialTaskReceive.c **** 	ptmp1->linesize  = linesize;
 431              		.loc 1 156 0 is_stmt 1
 432 007a A763     		str	r7, [r4, #56]
 157:Ourwares/SerialTaskReceive.c **** 	ptmp1->numline   = numline;
 433              		.loc 1 157 0
 434 007c A587     		strh	r5, [r4, #60]	@ movhi
 158:Ourwares/SerialTaskReceive.c **** 	ptmp1->dmaflag   = dmaflag;
 435              		.loc 1 158 0
 436 007e 84F84090 		strb	r9, [r4, #64]
 159:Ourwares/SerialTaskReceive.c **** 	ptmp1->pnoteval  = pnoteval;
 437              		.loc 1 159 0
 438 0082 84F841A0 		strb	r10, [r4, #65]
 160:Ourwares/SerialTaskReceive.c **** 	ptmp1->notebit   = notebit;
 439              		.loc 1 160 0
 440 0086 039B     		ldr	r3, [sp, #12]
 441 0088 A362     		str	r3, [r4, #40]
ARM GAS  /tmp/ccjG3mld.s 			page 16


 161:Ourwares/SerialTaskReceive.c **** 	ptmp1->phuart    = phuart;
 442              		.loc 1 161 0
 443 008a 029B     		ldr	r3, [sp, #8]
 444 008c 6362     		str	r3, [r4, #36]
 162:Ourwares/SerialTaskReceive.c **** 	ptmp1->tskhandle = xTaskGetCurrentTaskHandle();
 445              		.loc 1 162 0
 446 008e 019B     		ldr	r3, [sp, #4]
 447 0090 E361     		str	r3, [r4, #28]
 163:Ourwares/SerialTaskReceive.c **** 	ptmp1->errorct   = 0;
 448              		.loc 1 163 0
 449 0092 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 450              	.LVL44:
 451 0096 2062     		str	r0, [r4, #32]
 164:Ourwares/SerialTaskReceive.c **** 
 452              		.loc 1 164 0
 453 0098 0023     		movs	r3, #0
 454 009a A364     		str	r3, [r4, #72]
 167:Ourwares/SerialTaskReceive.c **** 	ptmp1->padd   = pbuf; // Pointer to where next line will be added
 455              		.loc 1 167 0
 456 009c 6660     		str	r6, [r4, #4]
 168:Ourwares/SerialTaskReceive.c **** 	ptmp1->ptake  = pbuf; // Pointer to where next line will be taken
 457              		.loc 1 168 0
 458 009e E660     		str	r6, [r4, #12]
 169:Ourwares/SerialTaskReceive.c **** 	ptmp1->pwork  = pbuf; // Pointer where next char in active line will be added
 459              		.loc 1 169 0
 460 00a0 2661     		str	r6, [r4, #16]
 170:Ourwares/SerialTaskReceive.c **** 	ptmp1->pworkend = pbuf + linesize - 2; // End of 1st LINE buffer (allow for zero terminator)
 461              		.loc 1 170 0
 462 00a2 6661     		str	r6, [r4, #20]
 171:Ourwares/SerialTaskReceive.c **** 	ptmp1->pend = pbuf + numline*linesize; // End of line buffers + 1 line
 463              		.loc 1 171 0
 464 00a4 023D     		subs	r5, r5, #2
 465              	.LVL45:
 466 00a6 3544     		add	r5, r5, r6
 467 00a8 A561     		str	r5, [r4, #24]
 172:Ourwares/SerialTaskReceive.c **** 	ptmp1->CANmode = CANmode;
 468              		.loc 1 172 0
 469 00aa 3744     		add	r7, r7, r6
 470 00ac A760     		str	r7, [r4, #8]
 173:Ourwares/SerialTaskReceive.c **** 
 471              		.loc 1 173 0
 472 00ae 84F84280 		strb	r8, [r4, #66]
 175:Ourwares/SerialTaskReceive.c **** 	{ // Circular DMA buffer 
 473              		.loc 1 175 0
 474 00b2 BAF1000F 		cmp	r10, #0
 475 00b6 22D0     		beq	.L36
 177:Ourwares/SerialTaskReceive.c **** 		if ( pbuf == NULL) return NULL;
 476              		.loc 1 177 0
 477 00b8 0121     		movs	r1, #1
 478 00ba 5846     		mov	r0, fp
 479 00bc FFF7FEFF 		bl	calloc
 480              	.LVL46:
 178:Ourwares/SerialTaskReceive.c **** 		ptmp1->pbegindma = pbuf;   // Pointer to beginning of DMA circular buffer
 481              		.loc 1 178 0
 482 00c0 60B3     		cbz	r0, .L42
 179:Ourwares/SerialTaskReceive.c **** 		ptmp1->penddma   = pbuf + dmasize; // Pointer to end + 1
 483              		.loc 1 179 0
ARM GAS  /tmp/ccjG3mld.s 			page 17


 484 00c2 E062     		str	r0, [r4, #44]
 180:Ourwares/SerialTaskReceive.c **** 		ptmp1->ptakedma  = pbuf;   // "Take" Pointer into DMA buffer
 485              		.loc 1 180 0
 486 00c4 00EB0B02 		add	r2, r0, fp
 487 00c8 2263     		str	r2, [r4, #48]
 181:Ourwares/SerialTaskReceive.c **** 		ptmp1->dmasize   = dmasize; // Total number of chars in DMA buffer
 488              		.loc 1 181 0
 489 00ca 6063     		str	r0, [r4, #52]
 182:Ourwares/SerialTaskReceive.c **** 
 490              		.loc 1 182 0
 491 00cc A4F83EB0 		strh	fp, [r4, #62]	@ movhi
 185:Ourwares/SerialTaskReceive.c **** 		{ // Initialize CAN conversion control block
 492              		.loc 1 185 0
 493 00d0 B8F1010F 		cmp	r8, #1
 494 00d4 08D1     		bne	.L37
 187:Ourwares/SerialTaskReceive.c **** 			if (pgptc == NULL)  {taskEXIT_CRITICAL();return NULL;}
 495              		.loc 1 187 0
 496 00d6 2046     		mov	r0, r4
 497              	.LVL47:
 498 00d8 FFF7FEFF 		bl	gateway_PCtoCAN_init
 499              	.LVL48:
 188:Ourwares/SerialTaskReceive.c **** 			ptmp1->pgptc = pgptc; // Save pointer to CAN conversion control block
 500              		.loc 1 188 0
 501 00dc 18B9     		cbnz	r0, .L38
 188:Ourwares/SerialTaskReceive.c **** 			ptmp1->pgptc = pgptc; // Save pointer to CAN conversion control block
 502              		.loc 1 188 0 is_stmt 0 discriminator 1
 503 00de FFF7FEFF 		bl	vPortExitCritical
 504              	.LVL49:
 505 00e2 0020     		movs	r0, #0
 506 00e4 1BE0     		b	.L31
 507              	.LVL50:
 508              	.L38:
 189:Ourwares/SerialTaskReceive.c **** 		}
 509              		.loc 1 189 0 is_stmt 1
 510 00e6 6064     		str	r0, [r4, #68]
 511              	.LVL51:
 512              	.L37:
 193:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 513              		.loc 1 193 0
 514 00e8 E28F     		ldrh	r2, [r4, #62]
 515 00ea E16A     		ldr	r1, [r4, #44]
 516 00ec E069     		ldr	r0, [r4, #28]
 517 00ee FFF7FEFF 		bl	HAL_UART_Receive_DMA
 518              	.LVL52:
 194:Ourwares/SerialTaskReceive.c **** 		{
 519              		.loc 1 194 0
 520 00f2 0128     		cmp	r0, #1
 521 00f4 0ED1     		bne	.L39
 196:Ourwares/SerialTaskReceive.c **** 			return NULL;
 522              		.loc 1 196 0
 523 00f6 FFF7FEFF 		bl	vPortExitCritical
 524              	.LVL53:
 197:Ourwares/SerialTaskReceive.c **** 		}
 525              		.loc 1 197 0
 526 00fa 0020     		movs	r0, #0
 527 00fc 0FE0     		b	.L31
 528              	.LVL54:
ARM GAS  /tmp/ccjG3mld.s 			page 18


 529              	.L36:
 202:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 530              		.loc 1 202 0
 531 00fe 0122     		movs	r2, #1
 532 0100 3146     		mov	r1, r6
 533 0102 E069     		ldr	r0, [r4, #28]
 534 0104 FFF7FEFF 		bl	HAL_UART_Receive_IT
 535              	.LVL55:
 203:Ourwares/SerialTaskReceive.c **** 		{
 536              		.loc 1 203 0
 537 0108 0128     		cmp	r0, #1
 538 010a 03D1     		bne	.L39
 205:Ourwares/SerialTaskReceive.c **** 			return NULL;
 539              		.loc 1 205 0
 540 010c FFF7FEFF 		bl	vPortExitCritical
 541              	.LVL56:
 206:Ourwares/SerialTaskReceive.c **** 		}
 542              		.loc 1 206 0
 543 0110 0020     		movs	r0, #0
 544 0112 04E0     		b	.L31
 545              	.LVL57:
 546              	.L39:
 209:Ourwares/SerialTaskReceive.c **** 	return ptmp1;	// Success return pointer to this 'BCB
 547              		.loc 1 209 0
 548 0114 FFF7FEFF 		bl	vPortExitCritical
 549              	.LVL58:
 210:Ourwares/SerialTaskReceive.c **** }
 550              		.loc 1 210 0
 551 0118 2046     		mov	r0, r4
 552 011a 00E0     		b	.L31
 553              	.LVL59:
 554              	.L42:
 178:Ourwares/SerialTaskReceive.c **** 		ptmp1->pbegindma = pbuf;   // Pointer to beginning of DMA circular buffer
 555              		.loc 1 178 0
 556 011c 0020     		movs	r0, #0
 557              	.LVL60:
 558              	.L31:
 211:Ourwares/SerialTaskReceive.c **** 
 559              		.loc 1 211 0
 560 011e 05B0     		add	sp, sp, #20
 561              	.LCFI8:
 562              		.cfi_def_cfa_offset 36
 563              		@ sp needed
 564 0120 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 565              	.LVL61:
 566              	.L45:
 567              		.align	2
 568              	.L44:
 569 0124 00000000 		.word	.LANCHOR0
 570              		.cfi_endproc
 571              	.LFE129:
 573              		.section	.text.xSerialTaskReceiveCreate,"ax",%progbits
 574              		.align	2
 575              		.global	xSerialTaskReceiveCreate
 576              		.thumb
 577              		.thumb_func
 579              	xSerialTaskReceiveCreate:
ARM GAS  /tmp/ccjG3mld.s 			page 19


 580              	.LFB131:
 265:Ourwares/SerialTaskReceive.c **** /*
 581              		.loc 1 265 0
 582              		.cfi_startproc
 583              		@ args = 0, pretend = 0, frame = 0
 584              		@ frame_needed = 0, uses_anonymous_args = 0
 585              	.LVL62:
 586 0000 00B5     		push	{lr}
 587              	.LCFI9:
 588              		.cfi_def_cfa_offset 4
 589              		.cfi_offset 14, -4
 590 0002 83B0     		sub	sp, sp, #12
 591              	.LCFI10:
 592              		.cfi_def_cfa_offset 16
 274:Ourwares/SerialTaskReceive.c ****      96, NULL, taskpriority,\
 593              		.loc 1 274 0
 594 0004 054B     		ldr	r3, .L48
 595 0006 0193     		str	r3, [sp, #4]
 596 0008 0090     		str	r0, [sp]
 597 000a 0023     		movs	r3, #0
 598 000c 6022     		movs	r2, #96
 599 000e 0449     		ldr	r1, .L48+4
 600 0010 0448     		ldr	r0, .L48+8
 601              	.LVL63:
 602 0012 FFF7FEFF 		bl	xTaskCreate
 603              	.LVL64:
 277:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 604              		.loc 1 277 0
 605 0016 03B0     		add	sp, sp, #12
 606              	.LCFI11:
 607              		.cfi_def_cfa_offset 4
 608              		@ sp needed
 609 0018 5DF804FB 		ldr	pc, [sp], #4
 610              	.L49:
 611              		.align	2
 612              	.L48:
 613 001c 00000000 		.word	.LANCHOR1
 614 0020 00000000 		.word	.LC0
 615 0024 00000000 		.word	StartSerialTaskReceive
 616              		.cfi_endproc
 617              	.LFE131:
 619              		.section	.text.xSerialTaskReceiveGetline,"ax",%progbits
 620              		.align	2
 621              		.global	xSerialTaskReceiveGetline
 622              		.thumb
 623              		.thumb_func
 625              	xSerialTaskReceiveGetline:
 626              	.LFB132:
 285:Ourwares/SerialTaskReceive.c **** 	char* p = NULL;
 627              		.loc 1 285 0
 628              		.cfi_startproc
 629              		@ args = 0, pretend = 0, frame = 0
 630              		@ frame_needed = 0, uses_anonymous_args = 0
 631              		@ link register save eliminated.
 632              	.LVL65:
 633 0000 0346     		mov	r3, r0
 634              	.LVL66:
ARM GAS  /tmp/ccjG3mld.s 			page 20


 289:Ourwares/SerialTaskReceive.c **** 	p = pbcb->ptake;
 635              		.loc 1 289 0
 636 0002 0069     		ldr	r0, [r0, #16]
 637              	.LVL67:
 638 0004 DA68     		ldr	r2, [r3, #12]
 639 0006 9042     		cmp	r0, r2
 640 0008 08D0     		beq	.L52
 641              	.LVL68:
 293:Ourwares/SerialTaskReceive.c **** 	if (pbcb->ptake >= pbcb->pend) pbcb->ptake = pbcb->pbegin;
 642              		.loc 1 293 0
 643 000a 9A8F     		ldrh	r2, [r3, #60]
 644 000c 0244     		add	r2, r2, r0
 645 000e 1A61     		str	r2, [r3, #16]
 294:Ourwares/SerialTaskReceive.c **** 
 646              		.loc 1 294 0
 647 0010 9968     		ldr	r1, [r3, #8]
 648 0012 8A42     		cmp	r2, r1
 649 0014 03D3     		bcc	.L51
 294:Ourwares/SerialTaskReceive.c **** 
 650              		.loc 1 294 0 is_stmt 0 discriminator 1
 651 0016 5A68     		ldr	r2, [r3, #4]
 652 0018 1A61     		str	r2, [r3, #16]
 653 001a 7047     		bx	lr
 654              	.LVL69:
 655              	.L52:
 289:Ourwares/SerialTaskReceive.c **** 	p = pbcb->ptake;
 656              		.loc 1 289 0 is_stmt 1
 657 001c 0020     		movs	r0, #0
 658              	.LVL70:
 659              	.L51:
 297:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 660              		.loc 1 297 0
 661 001e 7047     		bx	lr
 662              		.cfi_endproc
 663              	.LFE132:
 665              		.section	.text.HAL_UART_RxCpltCallback,"ax",%progbits
 666              		.align	2
 667              		.global	HAL_UART_RxCpltCallback
 668              		.thumb
 669              		.thumb_func
 671              	HAL_UART_RxCpltCallback:
 672              	.LFB137:
 384:Ourwares/SerialTaskReceive.c **** 
 385:Ourwares/SerialTaskReceive.c **** /* #######################################################################
 386:Ourwares/SerialTaskReceive.c ****    UART interrupt callbacks
 387:Ourwares/SerialTaskReceive.c ****    ####################################################################### */
 388:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 389:Ourwares/SerialTaskReceive.c ****  * void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *phuart);
 390:Ourwares/SerialTaskReceive.c ****  * @brief	: DMA callback at the halfway point in the circular buffer
 391:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 392:Ourwares/SerialTaskReceive.c **** /* NOTE: under interrupt from callback. */
 393:Ourwares/SerialTaskReceive.c **** 
 394:Ourwares/SerialTaskReceive.c **** /* DMA Half buffer complete callback (dma only) */
 395:Ourwares/SerialTaskReceive.c **** void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *phuart)
 396:Ourwares/SerialTaskReceive.c **** {
 397:Ourwares/SerialTaskReceive.c **** 	HAL_UART_RxCpltCallback(phuart);
 398:Ourwares/SerialTaskReceive.c **** }
ARM GAS  /tmp/ccjG3mld.s 			page 21


 399:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 400:Ourwares/SerialTaskReceive.c ****  * void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *phuart);
 401:Ourwares/SerialTaskReceive.c ****  * @brief	: DMA callback at the halfway point in the circular buffer
 402:Ourwares/SerialTaskReceive.c ****  *				: OR, char-by-char completion of sending
 403:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 404:Ourwares/SerialTaskReceive.c **** /* DMA buffer complete, => OR <= char-by-char complete */
 405:Ourwares/SerialTaskReceive.c **** 
 406:Ourwares/SerialTaskReceive.c **** void HAL_UART_RxCpltCallback(UART_HandleTypeDef *phuart)
 407:Ourwares/SerialTaskReceive.c **** {
 673              		.loc 1 407 0
 674              		.cfi_startproc
 675              		@ args = 0, pretend = 0, frame = 8
 676              		@ frame_needed = 0, uses_anonymous_args = 0
 677              	.LVL71:
 678 0000 30B5     		push	{r4, r5, lr}
 679              	.LCFI12:
 680              		.cfi_def_cfa_offset 12
 681              		.cfi_offset 4, -12
 682              		.cfi_offset 5, -8
 683              		.cfi_offset 14, -4
 684 0002 85B0     		sub	sp, sp, #20
 685              	.LCFI13:
 686              		.cfi_def_cfa_offset 32
 687 0004 0546     		mov	r5, r0
 408:Ourwares/SerialTaskReceive.c **** 	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 688              		.loc 1 408 0
 689 0006 0023     		movs	r3, #0
 690 0008 0393     		str	r3, [sp, #12]
 409:Ourwares/SerialTaskReceive.c **** 
 410:Ourwares/SerialTaskReceive.c **** 	/* Look up buffer control block, given uart handle */
 411:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 691              		.loc 1 411 0
 692 000a 154B     		ldr	r3, .L59
 693 000c 1C68     		ldr	r4, [r3]
 694              	.LVL72:
 412:Ourwares/SerialTaskReceive.c **** 	while (prtmp->phuart != phuart) prtmp++;
 695              		.loc 1 412 0
 696 000e 00E0     		b	.L54
 697              	.L55:
 698              		.loc 1 412 0 is_stmt 0 discriminator 2
 699 0010 4C34     		adds	r4, r4, #76
 700              	.LVL73:
 701              	.L54:
 702              		.loc 1 412 0 discriminator 1
 703 0012 E369     		ldr	r3, [r4, #28]
 704 0014 AB42     		cmp	r3, r5
 705 0016 FBD1     		bne	.L55
 413:Ourwares/SerialTaskReceive.c **** 
 414:Ourwares/SerialTaskReceive.c **** 	/* Note char-by-char mode from dma mode. */
 415:Ourwares/SerialTaskReceive.c **** 	if (prtmp->dmaflag == 0)
 706              		.loc 1 415 0 is_stmt 1
 707 0018 94F94130 		ldrsb	r3, [r4, #65]
 708 001c 53B9     		cbnz	r3, .L56
 416:Ourwares/SerialTaskReceive.c **** 	{ // Here char-by-char interrupt mode
 417:Ourwares/SerialTaskReceive.c **** 
 418:Ourwares/SerialTaskReceive.c **** 		// Note: char-by-char stores directly to line buffer
 419:Ourwares/SerialTaskReceive.c **** 		advanceptr(prtmp,*prtmp->pwork); 
ARM GAS  /tmp/ccjG3mld.s 			page 22


 709              		.loc 1 419 0
 710 001e 6369     		ldr	r3, [r4, #20]
 711 0020 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 712 0022 2046     		mov	r0, r4
 713              	.LVL74:
 714 0024 FFF7FEFF 		bl	advanceptr
 715              	.LVL75:
 420:Ourwares/SerialTaskReceive.c **** 
 421:Ourwares/SerialTaskReceive.c **** 		/* Restart receiving one char. */
 422:Ourwares/SerialTaskReceive.c **** 		HAL_UART_Receive_IT(phuart, (uint8_t*)prtmp->pwork, 1); // Get next char		
 716              		.loc 1 422 0
 717 0028 0122     		movs	r2, #1
 718 002a 6169     		ldr	r1, [r4, #20]
 719 002c 2846     		mov	r0, r5
 720 002e FFF7FEFF 		bl	HAL_UART_Receive_IT
 721              	.LVL76:
 423:Ourwares/SerialTaskReceive.c **** 		return;
 722              		.loc 1 423 0
 723 0032 12E0     		b	.L53
 724              	.LVL77:
 725              	.L56:
 424:Ourwares/SerialTaskReceive.c **** 	}
 425:Ourwares/SerialTaskReceive.c **** 
 426:Ourwares/SerialTaskReceive.c **** 	/* Trigger Recieve Task to poll dma uarts */
 427:Ourwares/SerialTaskReceive.c **** 	xTaskNotifyFromISR(SerialTaskReceiveHandle, 
 726              		.loc 1 427 0
 727 0034 0B4B     		ldr	r3, .L59+4
 728 0036 1868     		ldr	r0, [r3]
 729              	.LVL78:
 730 0038 03AB     		add	r3, sp, #12
 731 003a 0093     		str	r3, [sp]
 732 003c 0023     		movs	r3, #0
 733 003e 0122     		movs	r2, #1
 734 0040 1946     		mov	r1, r3
 735 0042 FFF7FEFF 		bl	xTaskGenericNotifyFromISR
 736              	.LVL79:
 428:Ourwares/SerialTaskReceive.c **** 		0,	/* 'or' bit assigned to buffer to notification value. */
 429:Ourwares/SerialTaskReceive.c **** 		eSetBits,      /* Set 'or' option */
 430:Ourwares/SerialTaskReceive.c **** 		&xHigherPriorityTaskWoken ); 
 431:Ourwares/SerialTaskReceive.c **** 
 432:Ourwares/SerialTaskReceive.c **** 	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 737              		.loc 1 432 0
 738 0046 039B     		ldr	r3, [sp, #12]
 739 0048 3BB1     		cbz	r3, .L53
 740              		.loc 1 432 0 is_stmt 0 discriminator 1
 741 004a 4FF08052 		mov	r2, #268435456
 742 004e 064B     		ldr	r3, .L59+8
 743 0050 1A60     		str	r2, [r3]
 744              		.syntax unified
 745              	@ 432 "Ourwares/SerialTaskReceive.c" 1
 746 0052 BFF34F8F 		dsb
 747              	@ 0 "" 2
 748              	@ 432 "Ourwares/SerialTaskReceive.c" 1
 749 0056 BFF36F8F 		isb
 750              	@ 0 "" 2
 751              		.thumb
 752              		.syntax unified
ARM GAS  /tmp/ccjG3mld.s 			page 23


 753              	.L53:
 433:Ourwares/SerialTaskReceive.c **** 	return;
 434:Ourwares/SerialTaskReceive.c **** }
 754              		.loc 1 434 0 is_stmt 1
 755 005a 05B0     		add	sp, sp, #20
 756              	.LCFI14:
 757              		.cfi_def_cfa_offset 12
 758              		@ sp needed
 759 005c 30BD     		pop	{r4, r5, pc}
 760              	.LVL80:
 761              	.L60:
 762 005e 00BF     		.align	2
 763              	.L59:
 764 0060 00000000 		.word	.LANCHOR0
 765 0064 00000000 		.word	.LANCHOR1
 766 0068 04ED00E0 		.word	-536810236
 767              		.cfi_endproc
 768              	.LFE137:
 770              		.section	.text.HAL_UART_RxHalfCpltCallback,"ax",%progbits
 771              		.align	2
 772              		.global	HAL_UART_RxHalfCpltCallback
 773              		.thumb
 774              		.thumb_func
 776              	HAL_UART_RxHalfCpltCallback:
 777              	.LFB136:
 396:Ourwares/SerialTaskReceive.c **** 	HAL_UART_RxCpltCallback(phuart);
 778              		.loc 1 396 0
 779              		.cfi_startproc
 780              		@ args = 0, pretend = 0, frame = 0
 781              		@ frame_needed = 0, uses_anonymous_args = 0
 782              	.LVL81:
 783 0000 08B5     		push	{r3, lr}
 784              	.LCFI15:
 785              		.cfi_def_cfa_offset 8
 786              		.cfi_offset 3, -8
 787              		.cfi_offset 14, -4
 397:Ourwares/SerialTaskReceive.c **** }
 788              		.loc 1 397 0
 789 0002 FFF7FEFF 		bl	HAL_UART_RxCpltCallback
 790              	.LVL82:
 791 0006 08BD     		pop	{r3, pc}
 792              		.cfi_endproc
 793              	.LFE136:
 795              		.section	.text.HAL_UART_ErrorCallback,"ax",%progbits
 796              		.align	2
 797              		.global	HAL_UART_ErrorCallback
 798              		.thumb
 799              		.thumb_func
 801              	HAL_UART_ErrorCallback:
 802              	.LFB138:
 435:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 436:Ourwares/SerialTaskReceive.c ****  * void HAL_UART_ErrorCallback(UART_HandleTypeDef *phuart);
 437:Ourwares/SerialTaskReceive.c ****  *	@brief	: Call back from receive errror, stm32f4xx_hal_uart
 438:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 439:Ourwares/SerialTaskReceive.c **** void HAL_UART_ErrorCallback(UART_HandleTypeDef *phuart)
 440:Ourwares/SerialTaskReceive.c **** {
 803              		.loc 1 440 0
ARM GAS  /tmp/ccjG3mld.s 			page 24


 804              		.cfi_startproc
 805              		@ args = 0, pretend = 0, frame = 0
 806              		@ frame_needed = 0, uses_anonymous_args = 0
 807              		@ link register save eliminated.
 808              	.LVL83:
 441:Ourwares/SerialTaskReceive.c **** 	/* Look up buffer control block, given uart handle */
 442:Ourwares/SerialTaskReceive.c **** 	/* Look up buffer control block, given uart handle */
 443:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 809              		.loc 1 443 0
 810 0000 054B     		ldr	r3, .L66
 811 0002 1B68     		ldr	r3, [r3]
 812              	.LVL84:
 444:Ourwares/SerialTaskReceive.c **** 	while (prtmp->phuart != phuart) prtmp++;
 813              		.loc 1 444 0
 814 0004 00E0     		b	.L64
 815              	.L65:
 816              		.loc 1 444 0 is_stmt 0 discriminator 2
 817 0006 4C33     		adds	r3, r3, #76
 818              	.LVL85:
 819              	.L64:
 820              		.loc 1 444 0 discriminator 1
 821 0008 DA69     		ldr	r2, [r3, #28]
 822 000a 8242     		cmp	r2, r0
 823 000c FBD1     		bne	.L65
 445:Ourwares/SerialTaskReceive.c **** 	prtmp->errorct += 1;
 824              		.loc 1 445 0 is_stmt 1
 825 000e 9A6C     		ldr	r2, [r3, #72]
 826 0010 0132     		adds	r2, r2, #1
 827 0012 9A64     		str	r2, [r3, #72]
 828 0014 7047     		bx	lr
 829              	.L67:
 830 0016 00BF     		.align	2
 831              	.L66:
 832 0018 00000000 		.word	.LANCHOR0
 833              		.cfi_endproc
 834              	.LFE138:
 836              		.global	SerialTaskReceiveHandle
 837              		.section	.rodata.str1.4,"aMS",%progbits,1
 838              		.align	2
 839              	.LC0:
 840 0000 53746172 		.ascii	"StartSerialTaskReceive\000"
 840      74536572 
 840      69616C54 
 840      61736B52 
 840      65636569 
 841              		.section	.bss.prbhd,"aw",%nobits
 842              		.align	2
 843              		.set	.LANCHOR0,. + 0
 846              	prbhd:
 847 0000 00000000 		.space	4
 848              		.section	.bss.SerialTaskReceiveHandle,"aw",%nobits
 849              		.align	2
 850              		.set	.LANCHOR1,. + 0
 853              	SerialTaskReceiveHandle:
 854 0000 00000000 		.space	4
 855              		.text
 856              	.Letext0:
ARM GAS  /tmp/ccjG3mld.s 			page 25


 857              		.file 2 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/_default_t
 858              		.file 3 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_stdint.h"
 859              		.file 4 "Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 860              		.file 5 "Middlewares/Third_Party/FreeRTOS/Source/include/task.h"
 861              		.file 6 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 862              		.file 7 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f407xx.h"
 863              		.file 8 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 864              		.file 9 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 865              		.file 10 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 866              		.file 11 "Ourwares/common_misc.h"
 867              		.file 12 "Ourwares/common_can.h"
 868              		.file 13 "Ourwares/SerialTaskReceive.h"
 869              		.file 14 "Drivers/CMSIS/Include/core_cm4.h"
 870              		.file 15 "Ourwares/gateway_PCtoCAN.h"
 871              		.file 16 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/malloc.h"
ARM GAS  /tmp/ccjG3mld.s 			page 26


DEFINED SYMBOLS
                            *ABS*:00000000 SerialTaskReceive.c
     /tmp/ccjG3mld.s:22     .text.advancebuf:00000000 $t
     /tmp/ccjG3mld.s:26     .text.advancebuf:00000000 advancebuf
     /tmp/ccjG3mld.s:103    .text.advancebuf:00000054 $d
     /tmp/ccjG3mld.s:108    .text.advanceptr:00000000 $t
     /tmp/ccjG3mld.s:112    .text.advanceptr:00000000 advanceptr
     /tmp/ccjG3mld.s:157    .text.unloaddma:00000000 $t
     /tmp/ccjG3mld.s:161    .text.unloaddma:00000000 unloaddma
     /tmp/ccjG3mld.s:230    .text.StartSerialTaskReceive:00000000 $t
     /tmp/ccjG3mld.s:235    .text.StartSerialTaskReceive:00000000 StartSerialTaskReceive
     /tmp/ccjG3mld.s:315    .text.StartSerialTaskReceive:00000050 $d
     /tmp/ccjG3mld.s:320    .text.xSerialTaskRxAdduart:00000000 $t
     /tmp/ccjG3mld.s:325    .text.xSerialTaskRxAdduart:00000000 xSerialTaskRxAdduart
     /tmp/ccjG3mld.s:569    .text.xSerialTaskRxAdduart:00000124 $d
     /tmp/ccjG3mld.s:574    .text.xSerialTaskReceiveCreate:00000000 $t
     /tmp/ccjG3mld.s:579    .text.xSerialTaskReceiveCreate:00000000 xSerialTaskReceiveCreate
     /tmp/ccjG3mld.s:613    .text.xSerialTaskReceiveCreate:0000001c $d
     /tmp/ccjG3mld.s:620    .text.xSerialTaskReceiveGetline:00000000 $t
     /tmp/ccjG3mld.s:625    .text.xSerialTaskReceiveGetline:00000000 xSerialTaskReceiveGetline
     /tmp/ccjG3mld.s:666    .text.HAL_UART_RxCpltCallback:00000000 $t
     /tmp/ccjG3mld.s:671    .text.HAL_UART_RxCpltCallback:00000000 HAL_UART_RxCpltCallback
     /tmp/ccjG3mld.s:764    .text.HAL_UART_RxCpltCallback:00000060 $d
     /tmp/ccjG3mld.s:771    .text.HAL_UART_RxHalfCpltCallback:00000000 $t
     /tmp/ccjG3mld.s:776    .text.HAL_UART_RxHalfCpltCallback:00000000 HAL_UART_RxHalfCpltCallback
     /tmp/ccjG3mld.s:796    .text.HAL_UART_ErrorCallback:00000000 $t
     /tmp/ccjG3mld.s:801    .text.HAL_UART_ErrorCallback:00000000 HAL_UART_ErrorCallback
     /tmp/ccjG3mld.s:832    .text.HAL_UART_ErrorCallback:00000018 $d
     /tmp/ccjG3mld.s:853    .bss.SerialTaskReceiveHandle:00000000 SerialTaskReceiveHandle
     /tmp/ccjG3mld.s:838    .rodata.str1.4:00000000 $d
     /tmp/ccjG3mld.s:842    .bss.prbhd:00000000 $d
     /tmp/ccjG3mld.s:846    .bss.prbhd:00000000 prbhd
     /tmp/ccjG3mld.s:849    .bss.SerialTaskReceiveHandle:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xTaskGenericNotifyFromISR
osDelay
xTaskNotifyWait
gateway_PCtoCAN_unloaddma
vPortEnterCritical
calloc
vPortExitCritical
xTaskGetCurrentTaskHandle
gateway_PCtoCAN_init
HAL_UART_Receive_DMA
HAL_UART_Receive_IT
xTaskCreate
