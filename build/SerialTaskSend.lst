ARM GAS  /tmp/ccpEzoQP.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.eabi_attribute 28, 1
   5              		.fpu fpv4-sp-d16
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.thumb
  16              		.syntax unified
  17              		.file	"SerialTaskSend.c"
  18              		.text
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.section	.text.StartSerialTaskSend,"ax",%progbits
  22              		.align	2
  23              		.global	StartSerialTaskSend
  24              		.thumb
  25              		.thumb_func
  27              	StartSerialTaskSend:
  28              	.LFB130:
  29              		.file 1 "Ourwares/SerialTaskSend.c"
   1:Ourwares/SerialTaskSend.c **** /******************************************************************************
   2:Ourwares/SerialTaskSend.c **** * File Name          : SerialTaskSend.c
   3:Ourwares/SerialTaskSend.c **** * Date First Issued  : 12/09/2018
   4:Ourwares/SerialTaskSend.c **** * Description        : Multiple task serial output using FreeRTOS/ST HAL
   5:Ourwares/SerialTaskSend.c **** *******************************************************************************/
   6:Ourwares/SerialTaskSend.c **** 
   7:Ourwares/SerialTaskSend.c **** #include "FreeRTOS.h"
   8:Ourwares/SerialTaskSend.c **** #include "task.h"
   9:Ourwares/SerialTaskSend.c **** #include "queue.h"
  10:Ourwares/SerialTaskSend.c **** #include "cmsis_os.h"
  11:Ourwares/SerialTaskSend.c **** #include "malloc.h"
  12:Ourwares/SerialTaskSend.c **** 
  13:Ourwares/SerialTaskSend.c **** #include "SerialTaskSend.h"
  14:Ourwares/SerialTaskSend.c **** 
  15:Ourwares/SerialTaskSend.c **** #include "stm32f4xx_hal_usart.h"
  16:Ourwares/SerialTaskSend.c **** #include "stm32f4xx_hal_uart.h"
  17:Ourwares/SerialTaskSend.c **** 
  18:Ourwares/SerialTaskSend.c **** 
  19:Ourwares/SerialTaskSend.c **** /*
  20:Ourwares/SerialTaskSend.c **** Goals: 
  21:Ourwares/SerialTaskSend.c **** - Use the HAl driver unmodified
  22:Ourwares/SerialTaskSend.c ****   .  Issue: the interrupt callback callback is common
  23:Ourwares/SerialTaskSend.c ****      to all uarts and carries a uart control block
  24:Ourwares/SerialTaskSend.c ****      pointer as an argument.
  25:Ourwares/SerialTaskSend.c **** 
  26:Ourwares/SerialTaskSend.c **** - (Maybe!) use same scheme with usb CDC.  Maybe same code?
  27:Ourwares/SerialTaskSend.c **** 
  28:Ourwares/SerialTaskSend.c **** - Handle 'n' uart/usarts 
  29:Ourwares/SerialTaskSend.c ****   .  So far, three have been used, so allowing for six
ARM GAS  /tmp/ccpEzoQP.s 			page 2


  30:Ourwares/SerialTaskSend.c ****      (stm32F407) may be overkill, but later stm32 versions
  31:Ourwares/SerialTaskSend.c ****      may allow even more.
  32:Ourwares/SerialTaskSend.c **** 
  33:Ourwares/SerialTaskSend.c **** - FreeRTOS can output serial data from multiple tasks
  34:Ourwares/SerialTaskSend.c **** 
  35:Ourwares/SerialTaskSend.c **** - Buffering:
  36:Ourwares/SerialTaskSend.c ****   .  Not depend on time before reusing a buffer, therefore
  37:Ourwares/SerialTaskSend.c ****      interrupts need to drive it.
  38:Ourwares/SerialTaskSend.c ****   .  Use a circular buffer that holds pointers
  39:Ourwares/SerialTaskSend.c ****      and handles to the originating task & task buffer.
  40:Ourwares/SerialTaskSend.c ****      .. copying char-by-char wasteful so use pointer control block
  41:Ourwares/SerialTaskSend.c ****      .. Multiple buffers for multiple uarts
  42:Ourwares/SerialTaskSend.c ****   .  Use source task's buffer and notify source task
  43:Ourwares/SerialTaskSend.c ****      when the buffer has been sent, using
  44:Ourwares/SerialTaskSend.c ****        'xTaskNotifyFromISR'
  45:Ourwares/SerialTaskSend.c **** 
  46:Ourwares/SerialTaskSend.c **** Scheme:
  47:Ourwares/SerialTaskSend.c **** 
  48:Ourwares/SerialTaskSend.c **** - Initialization:
  49:Ourwares/SerialTaskSend.c ****   .  Create, or add, to a linked list with pointer to next
  50:Ourwares/SerialTaskSend.c ****      block, uart/usart handle, and pointers to a circular
  51:Ourwares/SerialTaskSend.c ****      buffer calloc'ed for the number of task buffers to be used.
  52:Ourwares/SerialTaskSend.c ****      This done for each uart/usart implemented.
  53:Ourwares/SerialTaskSend.c **** 
  54:Ourwares/SerialTaskSend.c **** - Usage:
  55:Ourwares/SerialTaskSend.c ****   .  A task generates the bytes to be sent in a buffer.
  56:Ourwares/SerialTaskSend.c ****   .  A buffer control block is initialized with the 
  57:Ourwares/SerialTaskSend.c ****      task handle, uart/usart handle, buffer pointer, and
  58:Ourwares/SerialTaskSend.c ****      number of bytes to be sent (size).  (All but the size 
  59:Ourwares/SerialTaskSend.c ****      can be initialized before the task endless loop begins.)
  60:Ourwares/SerialTaskSend.c ****   .  The buffer control block (bcb) is sent to this routine's queue.
  61:Ourwares/SerialTaskSend.c ****      This routine removes the bcb from the queue and adds it
  62:Ourwares/SerialTaskSend.c ****      to the circular buffer for the uart/usart, then attempts
  63:Ourwares/SerialTaskSend.c ****      to send it with the HAL routine.  The HAL routine rejects
  64:Ourwares/SerialTaskSend.c ****      the attempt if it is already busy.
  65:Ourwares/SerialTaskSend.c ****   .  Upon interrupt, the interrupt callback routine checks 
  66:Ourwares/SerialTaskSend.c ****      the circular buffer for the uart/usart causing the completion
  67:Ourwares/SerialTaskSend.c ****      of the sending interrupt.  
  68:Ourwares/SerialTaskSend.c ****      .. It issues a "notification" to the task identified in the
  69:Ourwares/SerialTaskSend.c ****         circular buffer block, so that the originating task can
  70:Ourwares/SerialTaskSend.c ****         reuse the buffer.
  71:Ourwares/SerialTaskSend.c ****      .. It "removes" (moves the pointer) the bcb from the circular
  72:Ourwares/SerialTaskSend.c ****         buffer.  If more bcb's are in the circular buffer, it
  73:Ourwares/SerialTaskSend.c ****         starts the HAL routine with the next bcb.
  74:Ourwares/SerialTaskSend.c ****            
  75:Ourwares/SerialTaskSend.c **** Note: If a uart/usart is not called from multiple tasks, i.e.
  76:Ourwares/SerialTaskSend.c ****      just one task uses the usart/usart, and there is no need
  77:Ourwares/SerialTaskSend.c ****      to overlap processing in that task with more than one
  78:Ourwares/SerialTaskSend.c ****      output buffer, then this routine does not need to be used.
  79:Ourwares/SerialTaskSend.c **** 
  80:Ourwares/SerialTaskSend.c **** Multiple tasks can place "struct SERIALSENDTASKBCB" items (BCB) in a queue. 
  81:Ourwares/SerialTaskSend.c **** The BCB holds:
  82:Ourwares/SerialTaskSend.c ****  - Originating task handle
  83:Ourwares/SerialTaskSend.c ****  - uart/usart control block pointer
  84:Ourwares/SerialTaskSend.c ****  - buffer pointer
  85:Ourwares/SerialTaskSend.c ****  - buffer size
  86:Ourwares/SerialTaskSend.c ****  - uart|usart flag
ARM GAS  /tmp/ccpEzoQP.s 			page 3


  87:Ourwares/SerialTaskSend.c ****  - bits for notifying originating task when the buffer has been sent, (so
  88:Ourwares/SerialTaskSend.c ****      that the originating task can reuse the buffer).
  89:Ourwares/SerialTaskSend.c **** 
  90:Ourwares/SerialTaskSend.c **** A circular buffer of BCBs is created for each uart/usart.  The size of this
  91:Ourwares/SerialTaskSend.c **** circular buffer must be at least as large as the number of buffers of
  92:Ourwares/SerialTaskSend.c **** the tasks using this routine.
  93:Ourwares/SerialTaskSend.c **** 
  94:Ourwares/SerialTaskSend.c **** 
  95:Ourwares/SerialTaskSend.c **** 
  96:Ourwares/SerialTaskSend.c **** */
  97:Ourwares/SerialTaskSend.c **** 
  98:Ourwares/SerialTaskSend.c **** 
  99:Ourwares/SerialTaskSend.c **** /* Task */
 100:Ourwares/SerialTaskSend.c **** #define SSPRIORITY 1	// Priority for this task (0 = Normal, -3 = Idle)
 101:Ourwares/SerialTaskSend.c **** 
 102:Ourwares/SerialTaskSend.c **** //static uint32_t SerialTaskSendBuffer[ 64 ];
 103:Ourwares/SerialTaskSend.c **** 
 104:Ourwares/SerialTaskSend.c **** //static osStaticThreadDef_t SerialTaskSendControlBlock;
 105:Ourwares/SerialTaskSend.c **** 
 106:Ourwares/SerialTaskSend.c **** osThreadId SerialTaskHandle = NULL;
 107:Ourwares/SerialTaskSend.c **** 
 108:Ourwares/SerialTaskSend.c **** 
 109:Ourwares/SerialTaskSend.c **** /* Queue */
 110:Ourwares/SerialTaskSend.c **** #define QUEUESIZE 16	// Total size of bcb's tasks can queue up
 111:Ourwares/SerialTaskSend.c **** 
 112:Ourwares/SerialTaskSend.c **** osMessageQId SerialTaskSendQHandle;
 113:Ourwares/SerialTaskSend.c **** //static uint8_t SerialTaskSendQBuffer[ QUEUESIZE * sizeof( struct SERIALSENDTASKBCB ) ];
 114:Ourwares/SerialTaskSend.c **** //static osStaticMessageQDef_t SerialTaskSendQCB;
 115:Ourwares/SerialTaskSend.c **** 
 116:Ourwares/SerialTaskSend.c **** /* Pattern
 117:Ourwares/SerialTaskSend.c **** osMessageQId testQueue01Handle;
 118:Ourwares/SerialTaskSend.c **** uint8_t myQueue01Buffer[ 16 * sizeof( uint16_t ) ];
 119:Ourwares/SerialTaskSend.c **** osStaticMessageQDef_t myQueue01ControlBlock;
 120:Ourwares/SerialTaskSend.c **** */
 121:Ourwares/SerialTaskSend.c **** 
 122:Ourwares/SerialTaskSend.c **** /* Serial Send Cir Buf: Block with pointers into the circular buffer of pointers. */
 123:Ourwares/SerialTaskSend.c **** struct SSCIRBUF
 124:Ourwares/SerialTaskSend.c **** {
 125:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* pnext;
 126:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** pbegin;
 127:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** pend;
 128:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** padd;
 129:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** ptake;
 130:Ourwares/SerialTaskSend.c **** 	UART_HandleTypeDef* phuart;
 131:Ourwares/SerialTaskSend.c **** 	int8_t	dmaflag;           // 0 = char-by-char; 1 = dma
 132:Ourwares/SerialTaskSend.c **** };
 133:Ourwares/SerialTaskSend.c **** 
 134:Ourwares/SerialTaskSend.c **** /* Points to first of list of struct SSCIRBUF */
 135:Ourwares/SerialTaskSend.c **** struct SSCIRBUF* pbhd = NULL;
 136:Ourwares/SerialTaskSend.c **** 
 137:Ourwares/SerialTaskSend.c **** 
 138:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 139:Ourwares/SerialTaskSend.c ****  * BaseType_t xSerialTaskSendAdd(UART_HandleTypeDef* p, uint16_t qsize, int8_t dmaflag);
 140:Ourwares/SerialTaskSend.c ****  *	@brief	: Add a uart and circular buffer to a linked list
 141:Ourwares/SerialTaskSend.c ****  * @param	: p = pointer to uart control block
 142:Ourwares/SerialTaskSend.c ****  * @param	: qsize = total number of buffer control blocks circular buffer can hold
 143:Ourwares/SerialTaskSend.c ****  * @param	: dmaflag = 0 = char-by-char, 1 = dma
ARM GAS  /tmp/ccpEzoQP.s 			page 4


 144:Ourwares/SerialTaskSend.c ****  * @return	: 0 = OK, -1 = failed 1st calloc, -2 = failed 2nd calloc
 145:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 146:Ourwares/SerialTaskSend.c **** BaseType_t xSerialTaskSendAdd(UART_HandleTypeDef* p, uint16_t qsize, int8_t dmaflag)
 147:Ourwares/SerialTaskSend.c **** {
 148:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp1;
 149:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp2;
 150:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB** pssb;
 151:Ourwares/SerialTaskSend.c **** 
 152:Ourwares/SerialTaskSend.c **** taskENTER_CRITICAL();
 153:Ourwares/SerialTaskSend.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 154:Ourwares/SerialTaskSend.c **** 	ptmp1 = (struct SSCIRBUF*)calloc(1, sizeof(struct SSCIRBUF));
 155:Ourwares/SerialTaskSend.c **** 	if (ptmp1 == NULL) {taskEXIT_CRITICAL();return -1;}
 156:Ourwares/SerialTaskSend.c **** 	if (pbhd  == NULL) // Is this the first?
 157:Ourwares/SerialTaskSend.c **** 	{ // Yes
 158:Ourwares/SerialTaskSend.c **** 		pbhd = ptmp1;	// Point head to first on list
 159:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Point first item on list to self
 160:Ourwares/SerialTaskSend.c **** 	}
 161:Ourwares/SerialTaskSend.c **** 	else
 162:Ourwares/SerialTaskSend.c **** 	{ // No, one or more have been added
 163:Ourwares/SerialTaskSend.c **** 		/* Find end of list */
 164:Ourwares/SerialTaskSend.c **** 		ptmp2 = pbhd;	// Start at head
 165:Ourwares/SerialTaskSend.c **** 		while (ptmp2 != ptmp2->pnext) ptmp2 = ptmp2->pnext;
 166:Ourwares/SerialTaskSend.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 167:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Added block points to self
 168:Ourwares/SerialTaskSend.c **** 	}
 169:Ourwares/SerialTaskSend.c **** 
 170:Ourwares/SerialTaskSend.c **** 	/* Get memory for circular buffer of buffer control blocks (bcb) */	
 171:Ourwares/SerialTaskSend.c **** 	pssb = (struct SERIALSENDTASKBCB**)calloc(qsize, sizeof(struct SERIALSENDTASKBCB*));
 172:Ourwares/SerialTaskSend.c **** 	if ( pssb == NULL) {taskEXIT_CRITICAL();return -2;}
 173:Ourwares/SerialTaskSend.c **** 
 174:Ourwares/SerialTaskSend.c **** 	/* Initialize pointers for circular buffer */
 175:Ourwares/SerialTaskSend.c **** 	// ptmp1 points to last item on list
 176:Ourwares/SerialTaskSend.c **** 	ptmp1->pbegin  = pssb;
 177:Ourwares/SerialTaskSend.c **** 	ptmp1->padd    = pssb;
 178:Ourwares/SerialTaskSend.c **** 	ptmp1->ptake   = pssb;
 179:Ourwares/SerialTaskSend.c **** 	ptmp1->pend    = pssb + qsize;
 180:Ourwares/SerialTaskSend.c **** 	ptmp1->phuart  = p;
 181:Ourwares/SerialTaskSend.c **** 	ptmp1->dmaflag = dmaflag;
 182:Ourwares/SerialTaskSend.c **** taskEXIT_CRITICAL();
 183:Ourwares/SerialTaskSend.c **** 	return 0;
 184:Ourwares/SerialTaskSend.c **** }
 185:Ourwares/SerialTaskSend.c **** 
 186:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 187:Ourwares/SerialTaskSend.c ****  * void StartSerialTaskSend(void const * argument);
 188:Ourwares/SerialTaskSend.c ****  *	@brief	: Task startup
 189:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 190:Ourwares/SerialTaskSend.c **** void StartSerialTaskSend(void* argument1)
 191:Ourwares/SerialTaskSend.c **** {
  30              		.loc 1 191 0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 8
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              	.LVL0:
  35 0000 00B5     		push	{lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 4
  38              		.cfi_offset 14, -4
ARM GAS  /tmp/ccpEzoQP.s 			page 5


  39 0002 83B0     		sub	sp, sp, #12
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 16
  42              	.LVL1:
  43              	.L2:
 192:Ourwares/SerialTaskSend.c **** 	BaseType_t Qret;	// queue receive return
 193:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB*  pssb; // Copied item from queue
 194:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp;	// Circular buffer pointer block pointer
 195:Ourwares/SerialTaskSend.c **** 
 196:Ourwares/SerialTaskSend.c ****   /* Infinite loop */
 197:Ourwares/SerialTaskSend.c ****   for(;;)
 198:Ourwares/SerialTaskSend.c ****   {
 199:Ourwares/SerialTaskSend.c **** 		do
 200:Ourwares/SerialTaskSend.c **** 		{
 201:Ourwares/SerialTaskSend.c **** 		/* Wait indefinitely for someone to load something into the queue */
 202:Ourwares/SerialTaskSend.c **** 		/* Skip over empty returns, and NULL pointers that would cause trouble */
 203:Ourwares/SerialTaskSend.c **** 			Qret = xQueueReceive(SerialTaskSendQHandle,&pssb,portMAX_DELAY);
  44              		.loc 1 203 0
  45 0004 0023     		movs	r3, #0
  46 0006 4FF0FF32 		mov	r2, #-1
  47 000a 01A9     		add	r1, sp, #4
  48 000c 1F48     		ldr	r0, .L13
  49 000e 0068     		ldr	r0, [r0]
  50 0010 FFF7FEFF 		bl	xQueueGenericReceive
  51              	.LVL2:
 204:Ourwares/SerialTaskSend.c **** 			if (Qret == pdPASS) // Break loop if not empty
  52              		.loc 1 204 0
  53 0014 0128     		cmp	r0, #1
  54 0016 06D0     		beq	.L3
 205:Ourwares/SerialTaskSend.c **** 				break;
 206:Ourwares/SerialTaskSend.c **** 		} while ((pssb->phuart == NULL) || (pssb->tskhandle == NULL));
  55              		.loc 1 206 0
  56 0018 019B     		ldr	r3, [sp, #4]
  57 001a 1A68     		ldr	r2, [r3]
  58 001c 002A     		cmp	r2, #0
  59 001e F1D0     		beq	.L2
  60              		.loc 1 206 0 is_stmt 0 discriminator 1
  61 0020 5B68     		ldr	r3, [r3, #4]
  62 0022 002B     		cmp	r3, #0
  63 0024 EED0     		beq	.L2
  64              	.L3:
 207:Ourwares/SerialTaskSend.c **** 
 208:Ourwares/SerialTaskSend.c **** 		/* Add Q item to linked list for this uart/usart */
 209:Ourwares/SerialTaskSend.c **** 
 210:Ourwares/SerialTaskSend.c **** 		/* Find uart/usart list for this item from Q */
 211:Ourwares/SerialTaskSend.c **** 		ptmp = pbhd;
  65              		.loc 1 211 0 is_stmt 1
  66 0026 1A4B     		ldr	r3, .L13+4
  67 0028 1B68     		ldr	r3, [r3]
  68              	.LVL3:
 212:Ourwares/SerialTaskSend.c **** 		while (ptmp->phuart != pssb->phuart) ptmp = ptmp->pnext;
  69              		.loc 1 212 0
  70 002a 00E0     		b	.L5
  71              	.LVL4:
  72              	.L6:
  73              		.loc 1 212 0 is_stmt 0 discriminator 2
  74 002c 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccpEzoQP.s 			page 6


  75              	.LVL5:
  76              	.L5:
  77              		.loc 1 212 0 discriminator 1
  78 002e 5969     		ldr	r1, [r3, #20]
  79 0030 0198     		ldr	r0, [sp, #4]
  80 0032 0268     		ldr	r2, [r0]
  81 0034 9142     		cmp	r1, r2
  82 0036 F9D1     		bne	.L6
 213:Ourwares/SerialTaskSend.c **** 
 214:Ourwares/SerialTaskSend.c **** 	 	if ((pssb->pbuf == NULL) || (pssb->size == 0))
  83              		.loc 1 214 0 is_stmt 1
  84 0038 C268     		ldr	r2, [r0, #12]
  85 003a 0AB1     		cbz	r2, .L7
  86              		.loc 1 214 0 is_stmt 0 discriminator 1
  87 003c 028A     		ldrh	r2, [r0, #16]
  88 003e 32B9     		cbnz	r2, .L8
  89              	.L7:
 215:Ourwares/SerialTaskSend.c **** 		{ // Here, HAL is going to reject it
 216:Ourwares/SerialTaskSend.c ****   			/* Release buffer just sent to it can be reused. */
 217:Ourwares/SerialTaskSend.c **** 			xSemaphoreGive(pssb->semaphore);\
  90              		.loc 1 217 0 is_stmt 1
  91 0040 0023     		movs	r3, #0
  92              	.LVL6:
  93 0042 1A46     		mov	r2, r3
  94 0044 1946     		mov	r1, r3
  95 0046 8068     		ldr	r0, [r0, #8]
  96 0048 FFF7FEFF 		bl	xQueueGenericSend
  97              	.LVL7:
 218:Ourwares/SerialTaskSend.c **** 			return;
  98              		.loc 1 218 0
  99 004c 1AE0     		b	.L11
 100              	.LVL8:
 101              	.L8:
 219:Ourwares/SerialTaskSend.c **** 		}
 220:Ourwares/SerialTaskSend.c **** 
 221:Ourwares/SerialTaskSend.c **** 		/* Add bcb to circular buffer for this uart/usart */
 222:Ourwares/SerialTaskSend.c **** 		*ptmp->padd = pssb; //Copy BCB pointer into circular buffer
 102              		.loc 1 222 0
 103 004e DA68     		ldr	r2, [r3, #12]
 104 0050 1060     		str	r0, [r2]
 223:Ourwares/SerialTaskSend.c **** 
 224:Ourwares/SerialTaskSend.c **** 		ptmp->padd += 1;	// Advance list ptr with wraparound
 105              		.loc 1 224 0
 106 0052 DA68     		ldr	r2, [r3, #12]
 107 0054 0432     		adds	r2, r2, #4
 108 0056 DA60     		str	r2, [r3, #12]
 225:Ourwares/SerialTaskSend.c **** 		if (ptmp->padd == ptmp->pend) ptmp->padd = ptmp->pbegin;
 109              		.loc 1 225 0
 110 0058 9968     		ldr	r1, [r3, #8]
 111 005a 8A42     		cmp	r2, r1
 112 005c 01D1     		bne	.L9
 113              		.loc 1 225 0 is_stmt 0 discriminator 1
 114 005e 5A68     		ldr	r2, [r3, #4]
 115 0060 DA60     		str	r2, [r3, #12]
 116              	.L9:
 226:Ourwares/SerialTaskSend.c **** 		{		
 227:Ourwares/SerialTaskSend.c ****       /* If HAL for this uart/usart is busy nothing happens. */
ARM GAS  /tmp/ccpEzoQP.s 			page 7


 228:Ourwares/SerialTaskSend.c **** 			if (ptmp->dmaflag == 0) // send buffer via char-by-char or dma 
 117              		.loc 1 228 0 is_stmt 1
 118 0062 93F91830 		ldrsb	r3, [r3, #24]
 119              	.LVL9:
 120 0066 33B9     		cbnz	r3, .L10
 229:Ourwares/SerialTaskSend.c **** 	 			HAL_UART_Transmit_IT((UART_HandleTypeDef*)pssb->phuart,pssb->pbuf,pssb->size);
 121              		.loc 1 229 0
 122 0068 019B     		ldr	r3, [sp, #4]
 123 006a 1A8A     		ldrh	r2, [r3, #16]
 124 006c D968     		ldr	r1, [r3, #12]
 125 006e 1868     		ldr	r0, [r3]
 126 0070 FFF7FEFF 		bl	HAL_UART_Transmit_IT
 127              	.LVL10:
 128 0074 C6E7     		b	.L2
 129              	.L10:
 230:Ourwares/SerialTaskSend.c **** 			else		
 231:Ourwares/SerialTaskSend.c ****  				HAL_UART_Transmit_DMA((UART_HandleTypeDef*)pssb->phuart,pssb->pbuf,pssb->size);
 130              		.loc 1 231 0
 131 0076 019B     		ldr	r3, [sp, #4]
 132 0078 1A8A     		ldrh	r2, [r3, #16]
 133 007a D968     		ldr	r1, [r3, #12]
 134 007c 1868     		ldr	r0, [r3]
 135 007e FFF7FEFF 		bl	HAL_UART_Transmit_DMA
 136              	.LVL11:
 137 0082 BFE7     		b	.L2
 138              	.L11:
 232:Ourwares/SerialTaskSend.c **** 		}
 233:Ourwares/SerialTaskSend.c **** 	}
 234:Ourwares/SerialTaskSend.c **** }
 139              		.loc 1 234 0
 140 0084 03B0     		add	sp, sp, #12
 141              	.LCFI2:
 142              		.cfi_def_cfa_offset 4
 143              		@ sp needed
 144 0086 5DF804FB 		ldr	pc, [sp], #4
 145              	.L14:
 146 008a 00BF     		.align	2
 147              	.L13:
 148 008c 00000000 		.word	SerialTaskSendQHandle
 149 0090 00000000 		.word	.LANCHOR0
 150              		.cfi_endproc
 151              	.LFE130:
 153              		.section	.text.xSerialTaskSendAdd,"ax",%progbits
 154              		.align	2
 155              		.global	xSerialTaskSendAdd
 156              		.thumb
 157              		.thumb_func
 159              	xSerialTaskSendAdd:
 160              	.LFB129:
 147:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp1;
 161              		.loc 1 147 0
 162              		.cfi_startproc
 163              		@ args = 0, pretend = 0, frame = 0
 164              		@ frame_needed = 0, uses_anonymous_args = 0
 165              	.LVL12:
 166 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 167              	.LCFI3:
ARM GAS  /tmp/ccpEzoQP.s 			page 8


 168              		.cfi_def_cfa_offset 24
 169              		.cfi_offset 3, -24
 170              		.cfi_offset 4, -20
 171              		.cfi_offset 5, -16
 172              		.cfi_offset 6, -12
 173              		.cfi_offset 7, -8
 174              		.cfi_offset 14, -4
 175 0002 0746     		mov	r7, r0
 176 0004 0D46     		mov	r5, r1
 177 0006 1646     		mov	r6, r2
 152:Ourwares/SerialTaskSend.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 178              		.loc 1 152 0
 179 0008 FFF7FEFF 		bl	vPortEnterCritical
 180              	.LVL13:
 154:Ourwares/SerialTaskSend.c **** 	if (ptmp1 == NULL) {taskEXIT_CRITICAL();return -1;}
 181              		.loc 1 154 0
 182 000c 1C21     		movs	r1, #28
 183 000e 0120     		movs	r0, #1
 184 0010 FFF7FEFF 		bl	calloc
 185              	.LVL14:
 155:Ourwares/SerialTaskSend.c **** 	if (pbhd  == NULL) // Is this the first?
 186              		.loc 1 155 0
 187 0014 20B9     		cbnz	r0, .L16
 155:Ourwares/SerialTaskSend.c **** 	if (pbhd  == NULL) // Is this the first?
 188              		.loc 1 155 0 is_stmt 0 discriminator 1
 189 0016 FFF7FEFF 		bl	vPortExitCritical
 190              	.LVL15:
 191 001a 4FF0FF30 		mov	r0, #-1
 192 001e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 193              	.LVL16:
 194              	.L16:
 195 0020 0446     		mov	r4, r0
 156:Ourwares/SerialTaskSend.c **** 	{ // Yes
 196              		.loc 1 156 0 is_stmt 1
 197 0022 114B     		ldr	r3, .L23
 198 0024 1B68     		ldr	r3, [r3]
 199 0026 23B9     		cbnz	r3, .L18
 158:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Point first item on list to self
 200              		.loc 1 158 0
 201 0028 0F4B     		ldr	r3, .L23
 202 002a 1860     		str	r0, [r3]
 159:Ourwares/SerialTaskSend.c **** 	}
 203              		.loc 1 159 0
 204 002c 2060     		str	r0, [r4]
 205 002e 05E0     		b	.L19
 206              	.LVL17:
 207              	.L21:
 165:Ourwares/SerialTaskSend.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 208              		.loc 1 165 0
 209 0030 1346     		mov	r3, r2
 210              	.LVL18:
 211              	.L18:
 165:Ourwares/SerialTaskSend.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 212              		.loc 1 165 0 is_stmt 0 discriminator 1
 213 0032 1A68     		ldr	r2, [r3]
 214 0034 9342     		cmp	r3, r2
 215 0036 FBD1     		bne	.L21
ARM GAS  /tmp/ccpEzoQP.s 			page 9


 166:Ourwares/SerialTaskSend.c **** 		ptmp1->pnext = ptmp1; // Added block points to self
 216              		.loc 1 166 0 is_stmt 1
 217 0038 1C60     		str	r4, [r3]
 167:Ourwares/SerialTaskSend.c **** 	}
 218              		.loc 1 167 0
 219 003a 2460     		str	r4, [r4]
 220              	.LVL19:
 221              	.L19:
 171:Ourwares/SerialTaskSend.c **** 	if ( pssb == NULL) {taskEXIT_CRITICAL();return -2;}
 222              		.loc 1 171 0
 223 003c 0421     		movs	r1, #4
 224 003e 2846     		mov	r0, r5
 225              	.LVL20:
 226 0040 FFF7FEFF 		bl	calloc
 227              	.LVL21:
 172:Ourwares/SerialTaskSend.c **** 
 228              		.loc 1 172 0
 229 0044 20B9     		cbnz	r0, .L20
 172:Ourwares/SerialTaskSend.c **** 
 230              		.loc 1 172 0 is_stmt 0 discriminator 1
 231 0046 FFF7FEFF 		bl	vPortExitCritical
 232              	.LVL22:
 233 004a 6FF00100 		mvn	r0, #1
 234 004e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 235              	.LVL23:
 236              	.L20:
 176:Ourwares/SerialTaskSend.c **** 	ptmp1->padd    = pssb;
 237              		.loc 1 176 0 is_stmt 1
 238 0050 6060     		str	r0, [r4, #4]
 177:Ourwares/SerialTaskSend.c **** 	ptmp1->ptake   = pssb;
 239              		.loc 1 177 0
 240 0052 E060     		str	r0, [r4, #12]
 178:Ourwares/SerialTaskSend.c **** 	ptmp1->pend    = pssb + qsize;
 241              		.loc 1 178 0
 242 0054 2061     		str	r0, [r4, #16]
 179:Ourwares/SerialTaskSend.c **** 	ptmp1->phuart  = p;
 243              		.loc 1 179 0
 244 0056 00EB8501 		add	r1, r0, r5, lsl #2
 245 005a A160     		str	r1, [r4, #8]
 180:Ourwares/SerialTaskSend.c **** 	ptmp1->dmaflag = dmaflag;
 246              		.loc 1 180 0
 247 005c 6761     		str	r7, [r4, #20]
 181:Ourwares/SerialTaskSend.c **** taskEXIT_CRITICAL();
 248              		.loc 1 181 0
 249 005e 2676     		strb	r6, [r4, #24]
 182:Ourwares/SerialTaskSend.c **** 	return 0;
 250              		.loc 1 182 0
 251 0060 FFF7FEFF 		bl	vPortExitCritical
 252              	.LVL24:
 183:Ourwares/SerialTaskSend.c **** }
 253              		.loc 1 183 0
 254 0064 0020     		movs	r0, #0
 184:Ourwares/SerialTaskSend.c **** 
 255              		.loc 1 184 0
 256 0066 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 257              	.LVL25:
 258              	.L24:
ARM GAS  /tmp/ccpEzoQP.s 			page 10


 259              		.align	2
 260              	.L23:
 261 0068 00000000 		.word	.LANCHOR0
 262              		.cfi_endproc
 263              	.LFE129:
 265              		.section	.text.xSerialTaskSendCreate,"ax",%progbits
 266              		.align	2
 267              		.global	xSerialTaskSendCreate
 268              		.thumb
 269              		.thumb_func
 271              	xSerialTaskSendCreate:
 272              	.LFB131:
 235:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 236:Ourwares/SerialTaskSend.c ****  * osThreadId xSerialTaskSendCreate(uint32_t taskpriority);
 237:Ourwares/SerialTaskSend.c ****  * @brief	: Create task; task handle created is global for all to enjoy!
 238:Ourwares/SerialTaskSend.c ****  * @param	: taskpriority = Task priority (just as it says!)
 239:Ourwares/SerialTaskSend.c ****  * @return	: SerialTaskSendHandle
 240:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 241:Ourwares/SerialTaskSend.c **** osThreadId xSerialTaskSendCreate(uint32_t taskpriority)
 242:Ourwares/SerialTaskSend.c **** {
 273              		.loc 1 242 0
 274              		.cfi_startproc
 275              		@ args = 0, pretend = 0, frame = 0
 276              		@ frame_needed = 0, uses_anonymous_args = 0
 277              	.LVL26:
 278 0000 00B5     		push	{lr}
 279              	.LCFI4:
 280              		.cfi_def_cfa_offset 4
 281              		.cfi_offset 14, -4
 282 0002 83B0     		sub	sp, sp, #12
 283              	.LCFI5:
 284              		.cfi_def_cfa_offset 16
 243:Ourwares/SerialTaskSend.c **** /*
 244:Ourwares/SerialTaskSend.c **** BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
 245:Ourwares/SerialTaskSend.c **** const char * const pcName,
 246:Ourwares/SerialTaskSend.c **** unsigned short usStackDepth,
 247:Ourwares/SerialTaskSend.c **** void *pvParameters,
 248:Ourwares/SerialTaskSend.c **** UBaseType_t uxPriority,
 249:Ourwares/SerialTaskSend.c **** TaskHandle_t *pxCreatedTask );
 250:Ourwares/SerialTaskSend.c **** */
 251:Ourwares/SerialTaskSend.c **** 	BaseType_t ret = xTaskCreate(StartSerialTaskSend, "SerialTaskSend",\
 285              		.loc 1 251 0
 286 0004 0C4B     		ldr	r3, .L29
 287 0006 0193     		str	r3, [sp, #4]
 288 0008 0090     		str	r0, [sp]
 289 000a 0023     		movs	r3, #0
 290 000c 6022     		movs	r2, #96
 291 000e 0B49     		ldr	r1, .L29+4
 292 0010 0B48     		ldr	r0, .L29+8
 293              	.LVL27:
 294 0012 FFF7FEFF 		bl	xTaskCreate
 295              	.LVL28:
 252:Ourwares/SerialTaskSend.c ****      96, NULL, taskpriority,\
 253:Ourwares/SerialTaskSend.c ****      &SerialTaskHandle);
 254:Ourwares/SerialTaskSend.c **** 	if (ret != pdPASS) return NULL;
 296              		.loc 1 254 0
 297 0016 0128     		cmp	r0, #1
ARM GAS  /tmp/ccpEzoQP.s 			page 11


 298 0018 0AD1     		bne	.L27
 255:Ourwares/SerialTaskSend.c **** 
 256:Ourwares/SerialTaskSend.c **** 	SerialTaskSendQHandle = xQueueCreate(QUEUESIZE, sizeof(struct SERIALSENDTASKBCB) );
 299              		.loc 1 256 0
 300 001a 0022     		movs	r2, #0
 301 001c 1421     		movs	r1, #20
 302 001e 1020     		movs	r0, #16
 303              	.LVL29:
 304 0020 FFF7FEFF 		bl	xQueueGenericCreate
 305              	.LVL30:
 306 0024 074B     		ldr	r3, .L29+12
 307 0026 1860     		str	r0, [r3]
 257:Ourwares/SerialTaskSend.c **** 	if (SerialTaskSendQHandle == NULL) return NULL;
 308              		.loc 1 257 0
 309 0028 18B1     		cbz	r0, .L26
 258:Ourwares/SerialTaskSend.c **** 	return SerialTaskHandle;
 310              		.loc 1 258 0
 311 002a 034B     		ldr	r3, .L29
 312 002c 1868     		ldr	r0, [r3]
 313 002e 00E0     		b	.L26
 314              	.LVL31:
 315              	.L27:
 254:Ourwares/SerialTaskSend.c **** 
 316              		.loc 1 254 0
 317 0030 0020     		movs	r0, #0
 318              	.LVL32:
 319              	.L26:
 259:Ourwares/SerialTaskSend.c **** }
 320              		.loc 1 259 0
 321 0032 03B0     		add	sp, sp, #12
 322              	.LCFI6:
 323              		.cfi_def_cfa_offset 4
 324              		@ sp needed
 325 0034 5DF804FB 		ldr	pc, [sp], #4
 326              	.L30:
 327              		.align	2
 328              	.L29:
 329 0038 00000000 		.word	.LANCHOR1
 330 003c 00000000 		.word	.LC0
 331 0040 00000000 		.word	StartSerialTaskSend
 332 0044 00000000 		.word	SerialTaskSendQHandle
 333              		.cfi_endproc
 334              	.LFE131:
 336              		.section	.text.HAL_UART_TxCpltCallback,"ax",%progbits
 337              		.align	2
 338              		.global	HAL_UART_TxCpltCallback
 339              		.thumb
 340              		.thumb_func
 342              	HAL_UART_TxCpltCallback:
 343              	.LFB132:
 260:Ourwares/SerialTaskSend.c **** /* #######################################################################
 261:Ourwares/SerialTaskSend.c ****    UART interrupt callback: file|size has been sent
 262:Ourwares/SerialTaskSend.c ****    ####################################################################### */
 263:Ourwares/SerialTaskSend.c **** void HAL_UART_TxCpltCallback(UART_HandleTypeDef *phuart)
 264:Ourwares/SerialTaskSend.c **** {
 344              		.loc 1 264 0
 345              		.cfi_startproc
ARM GAS  /tmp/ccpEzoQP.s 			page 12


 346              		@ args = 0, pretend = 0, frame = 8
 347              		@ frame_needed = 0, uses_anonymous_args = 0
 348              	.LVL33:
 349 0000 10B5     		push	{r4, lr}
 350              	.LCFI7:
 351              		.cfi_def_cfa_offset 8
 352              		.cfi_offset 4, -8
 353              		.cfi_offset 14, -4
 354 0002 82B0     		sub	sp, sp, #8
 355              	.LCFI8:
 356              		.cfi_def_cfa_offset 16
 265:Ourwares/SerialTaskSend.c **** 	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 357              		.loc 1 265 0
 358 0004 0023     		movs	r3, #0
 359 0006 0193     		str	r3, [sp, #4]
 266:Ourwares/SerialTaskSend.c **** 
 267:Ourwares/SerialTaskSend.c **** 	struct SERIALSENDTASKBCB* pbcb; // Buffer control block ptr
 268:Ourwares/SerialTaskSend.c **** 	struct SSCIRBUF* ptmp1;	// Linked list of usarts
 269:Ourwares/SerialTaskSend.c **** 
 270:Ourwares/SerialTaskSend.c **** 	/* Find bcb circular buffer for this uart */
 271:Ourwares/SerialTaskSend.c **** 	ptmp1 = pbhd; // Polnt to first on list
 360              		.loc 1 271 0
 361 0008 194B     		ldr	r3, .L39
 362 000a 1C68     		ldr	r4, [r3]
 363              	.LVL34:
 272:Ourwares/SerialTaskSend.c **** 	while (ptmp1->phuart != phuart) 
 364              		.loc 1 272 0
 365 000c 00E0     		b	.L32
 366              	.L33:
 273:Ourwares/SerialTaskSend.c **** 	{
 274:Ourwares/SerialTaskSend.c **** 		ptmp1 = ptmp1->pnext; // Step to next uart
 367              		.loc 1 274 0
 368 000e 2468     		ldr	r4, [r4]
 369              	.LVL35:
 370              	.L32:
 272:Ourwares/SerialTaskSend.c **** 	while (ptmp1->phuart != phuart) 
 371              		.loc 1 272 0
 372 0010 6369     		ldr	r3, [r4, #20]
 373 0012 8342     		cmp	r3, r0
 374 0014 FBD1     		bne	.L33
 275:Ourwares/SerialTaskSend.c **** 	}
 276:Ourwares/SerialTaskSend.c **** 
 277:Ourwares/SerialTaskSend.c **** 	/* Pointr to buffer control block for next buffer to send. */
 278:Ourwares/SerialTaskSend.c **** 	pbcb = *ptmp1->ptake;
 375              		.loc 1 278 0
 376 0016 2369     		ldr	r3, [r4, #16]
 377 0018 1B68     		ldr	r3, [r3]
 378              	.LVL36:
 279:Ourwares/SerialTaskSend.c **** 
 280:Ourwares/SerialTaskSend.c ****    /* Release buffer just sent to it can be reused. */
 281:Ourwares/SerialTaskSend.c **** 	xSemaphoreGiveFromISR( pbcb->semaphore, &xHigherPriorityTaskWoken );
 379              		.loc 1 281 0
 380 001a 01A9     		add	r1, sp, #4
 381 001c 9868     		ldr	r0, [r3, #8]
 382              	.LVL37:
 383 001e FFF7FEFF 		bl	xQueueGiveFromISR
 384              	.LVL38:
ARM GAS  /tmp/ccpEzoQP.s 			page 13


 282:Ourwares/SerialTaskSend.c **** 
 283:Ourwares/SerialTaskSend.c **** 	/* Advance 'take' pointer of circular buffer. */
 284:Ourwares/SerialTaskSend.c **** 	ptmp1->ptake += 1;	// Advance ptr with wraparound
 385              		.loc 1 284 0
 386 0022 2369     		ldr	r3, [r4, #16]
 387 0024 0433     		adds	r3, r3, #4
 388 0026 2361     		str	r3, [r4, #16]
 285:Ourwares/SerialTaskSend.c **** 	if (ptmp1->ptake == ptmp1->pend) ptmp1->ptake = ptmp1->pbegin;	
 389              		.loc 1 285 0
 390 0028 A268     		ldr	r2, [r4, #8]
 391 002a 9342     		cmp	r3, r2
 392 002c 01D1     		bne	.L34
 393              		.loc 1 285 0 is_stmt 0 discriminator 1
 394 002e 6368     		ldr	r3, [r4, #4]
 395 0030 2361     		str	r3, [r4, #16]
 396              	.L34:
 286:Ourwares/SerialTaskSend.c **** 
 287:Ourwares/SerialTaskSend.c **** 	/* If more bcb remain in the buffer start the next sending. */
 288:Ourwares/SerialTaskSend.c **** 	if (ptmp1->ptake != ptmp1->padd)
 397              		.loc 1 288 0 is_stmt 1
 398 0032 2369     		ldr	r3, [r4, #16]
 399 0034 E268     		ldr	r2, [r4, #12]
 400 0036 9342     		cmp	r3, r2
 401 0038 0ED0     		beq	.L35
 289:Ourwares/SerialTaskSend.c **** 	{
 290:Ourwares/SerialTaskSend.c **** 		pbcb = *ptmp1->ptake;
 402              		.loc 1 290 0
 403 003a 1B68     		ldr	r3, [r3]
 404              	.LVL39:
 291:Ourwares/SerialTaskSend.c **** 		if (ptmp1->dmaflag == 0)
 405              		.loc 1 291 0
 406 003c 94F91820 		ldrsb	r2, [r4, #24]
 407 0040 2AB9     		cbnz	r2, .L36
 292:Ourwares/SerialTaskSend.c **** 			HAL_UART_Transmit_IT (pbcb->phuart,pbcb->pbuf,pbcb->size);
 408              		.loc 1 292 0
 409 0042 1A8A     		ldrh	r2, [r3, #16]
 410 0044 D968     		ldr	r1, [r3, #12]
 411 0046 1868     		ldr	r0, [r3]
 412 0048 FFF7FEFF 		bl	HAL_UART_Transmit_IT
 413              	.LVL40:
 414 004c 04E0     		b	.L35
 415              	.LVL41:
 416              	.L36:
 293:Ourwares/SerialTaskSend.c **** 		else
 294:Ourwares/SerialTaskSend.c **** 			HAL_UART_Transmit_DMA(pbcb->phuart,pbcb->pbuf,pbcb->size);
 417              		.loc 1 294 0
 418 004e 1A8A     		ldrh	r2, [r3, #16]
 419 0050 D968     		ldr	r1, [r3, #12]
 420 0052 1868     		ldr	r0, [r3]
 421 0054 FFF7FEFF 		bl	HAL_UART_Transmit_DMA
 422              	.LVL42:
 423              	.L35:
 295:Ourwares/SerialTaskSend.c **** 	}
 296:Ourwares/SerialTaskSend.c **** 	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 424              		.loc 1 296 0
 425 0058 019B     		ldr	r3, [sp, #4]
 426 005a 3BB1     		cbz	r3, .L31
ARM GAS  /tmp/ccpEzoQP.s 			page 14


 427              		.loc 1 296 0 is_stmt 0 discriminator 1
 428 005c 4FF08052 		mov	r2, #268435456
 429 0060 044B     		ldr	r3, .L39+4
 430 0062 1A60     		str	r2, [r3]
 431              		.syntax unified
 432              	@ 296 "Ourwares/SerialTaskSend.c" 1
 433 0064 BFF34F8F 		dsb
 434              	@ 0 "" 2
 435              	@ 296 "Ourwares/SerialTaskSend.c" 1
 436 0068 BFF36F8F 		isb
 437              	@ 0 "" 2
 438              		.thumb
 439              		.syntax unified
 440              	.L31:
 297:Ourwares/SerialTaskSend.c **** 	return;
 298:Ourwares/SerialTaskSend.c **** }
 441              		.loc 1 298 0 is_stmt 1
 442 006c 02B0     		add	sp, sp, #8
 443              	.LCFI9:
 444              		.cfi_def_cfa_offset 8
 445              		@ sp needed
 446 006e 10BD     		pop	{r4, pc}
 447              	.LVL43:
 448              	.L40:
 449              		.align	2
 450              	.L39:
 451 0070 00000000 		.word	.LANCHOR0
 452 0074 04ED00E0 		.word	-536810236
 453              		.cfi_endproc
 454              	.LFE132:
 456              		.section	.text.vSerialTaskSendQueueBuf,"ax",%progbits
 457              		.align	2
 458              		.global	vSerialTaskSendQueueBuf
 459              		.thumb
 460              		.thumb_func
 462              	vSerialTaskSendQueueBuf:
 463              	.LFB133:
 299:Ourwares/SerialTaskSend.c **** 
 300:Ourwares/SerialTaskSend.c **** /* *************************************************************************
 301:Ourwares/SerialTaskSend.c ****  * void vSerialTaskSendQueueBuf(struct SERIALSENDTASKBCB** ppbcb);
 302:Ourwares/SerialTaskSend.c ****  *	@brief	: Load buffer control block onto queue for sending
 303:Ourwares/SerialTaskSend.c ****  * @param	: ppbcb = Pointer to pointer to Buffer Control Block
 304:Ourwares/SerialTaskSend.c ****  * *************************************************************************/
 305:Ourwares/SerialTaskSend.c **** void vSerialTaskSendQueueBuf(struct SERIALSENDTASKBCB** ppbcb)
 306:Ourwares/SerialTaskSend.c **** {
 464              		.loc 1 306 0
 465              		.cfi_startproc
 466              		@ args = 0, pretend = 0, frame = 0
 467              		@ frame_needed = 0, uses_anonymous_args = 0
 468              	.LVL44:
 469 0000 38B5     		push	{r3, r4, r5, lr}
 470              	.LCFI10:
 471              		.cfi_def_cfa_offset 16
 472              		.cfi_offset 3, -16
 473              		.cfi_offset 4, -12
 474              		.cfi_offset 5, -8
 475              		.cfi_offset 14, -4
ARM GAS  /tmp/ccpEzoQP.s 			page 15


 476 0002 0546     		mov	r5, r0
 477              	.LVL45:
 478              	.L43:
 307:Ourwares/SerialTaskSend.c **** 	uint32_t qret;
 308:Ourwares/SerialTaskSend.c **** 
 309:Ourwares/SerialTaskSend.c **** 	do 
 310:Ourwares/SerialTaskSend.c **** 	{
 311:Ourwares/SerialTaskSend.c **** 		qret=xQueueSendToBack(SerialTaskSendQHandle, ppbcb, portMAX_DELAY);
 479              		.loc 1 311 0
 480 0004 0023     		movs	r3, #0
 481 0006 4FF0FF32 		mov	r2, #-1
 482 000a 2946     		mov	r1, r5
 483 000c 0548     		ldr	r0, .L45
 484 000e 0068     		ldr	r0, [r0]
 485 0010 FFF7FEFF 		bl	xQueueGenericSend
 486              	.LVL46:
 312:Ourwares/SerialTaskSend.c **** 		if (qret == errQUEUE_FULL) osDelay(1); // Delay, don't spin.
 487              		.loc 1 312 0
 488 0014 0446     		mov	r4, r0
 489 0016 10B9     		cbnz	r0, .L42
 490              		.loc 1 312 0 is_stmt 0 discriminator 1
 491 0018 0120     		movs	r0, #1
 492              	.LVL47:
 493 001a FFF7FEFF 		bl	osDelay
 494              	.LVL48:
 495              	.L42:
 313:Ourwares/SerialTaskSend.c **** 
 314:Ourwares/SerialTaskSend.c **** 	} while(qret == errQUEUE_FULL);
 496              		.loc 1 314 0 is_stmt 1
 497 001e 002C     		cmp	r4, #0
 498 0020 F0D0     		beq	.L43
 315:Ourwares/SerialTaskSend.c **** 	return;
 316:Ourwares/SerialTaskSend.c **** }
 499              		.loc 1 316 0
 500 0022 38BD     		pop	{r3, r4, r5, pc}
 501              	.LVL49:
 502              	.L46:
 503              		.align	2
 504              	.L45:
 505 0024 00000000 		.word	SerialTaskSendQHandle
 506              		.cfi_endproc
 507              	.LFE133:
 509              		.global	pbhd
 510              		.comm	SerialTaskSendQHandle,4,4
 511              		.global	SerialTaskHandle
 512              		.section	.bss.pbhd,"aw",%nobits
 513              		.align	2
 514              		.set	.LANCHOR0,. + 0
 517              	pbhd:
 518 0000 00000000 		.space	4
 519              		.section	.bss.SerialTaskHandle,"aw",%nobits
 520              		.align	2
 521              		.set	.LANCHOR1,. + 0
 524              	SerialTaskHandle:
 525 0000 00000000 		.space	4
 526              		.section	.rodata.str1.4,"aMS",%progbits,1
 527              		.align	2
ARM GAS  /tmp/ccpEzoQP.s 			page 16


 528              	.LC0:
 529 0000 53657269 		.ascii	"SerialTaskSend\000"
 529      616C5461 
 529      736B5365 
 529      6E6400
 530              		.text
 531              	.Letext0:
 532              		.file 2 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/_default_t
 533              		.file 3 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_stdint.h"
 534              		.file 4 "Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM4F/portmacro.h"
 535              		.file 5 "Middlewares/Third_Party/FreeRTOS/Source/include/task.h"
 536              		.file 6 "Middlewares/Third_Party/FreeRTOS/Source/include/queue.h"
 537              		.file 7 "Middlewares/Third_Party/FreeRTOS/Source/include/semphr.h"
 538              		.file 8 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 539              		.file 9 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/stm32f407xx.h"
 540              		.file 10 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_def.h"
 541              		.file 11 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_dma.h"
 542              		.file 12 "Drivers/STM32F4xx_HAL_Driver/Inc/stm32f4xx_hal_uart.h"
 543              		.file 13 "Ourwares/SerialTaskSend.h"
 544              		.file 14 "Drivers/CMSIS/Include/core_cm4.h"
 545              		.file 15 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/malloc.h"
ARM GAS  /tmp/ccpEzoQP.s 			page 17


DEFINED SYMBOLS
                            *ABS*:00000000 SerialTaskSend.c
     /tmp/ccpEzoQP.s:22     .text.StartSerialTaskSend:00000000 $t
     /tmp/ccpEzoQP.s:27     .text.StartSerialTaskSend:00000000 StartSerialTaskSend
     /tmp/ccpEzoQP.s:148    .text.StartSerialTaskSend:0000008c $d
                            *COM*:00000004 SerialTaskSendQHandle
     /tmp/ccpEzoQP.s:154    .text.xSerialTaskSendAdd:00000000 $t
     /tmp/ccpEzoQP.s:159    .text.xSerialTaskSendAdd:00000000 xSerialTaskSendAdd
     /tmp/ccpEzoQP.s:261    .text.xSerialTaskSendAdd:00000068 $d
     /tmp/ccpEzoQP.s:266    .text.xSerialTaskSendCreate:00000000 $t
     /tmp/ccpEzoQP.s:271    .text.xSerialTaskSendCreate:00000000 xSerialTaskSendCreate
     /tmp/ccpEzoQP.s:329    .text.xSerialTaskSendCreate:00000038 $d
     /tmp/ccpEzoQP.s:337    .text.HAL_UART_TxCpltCallback:00000000 $t
     /tmp/ccpEzoQP.s:342    .text.HAL_UART_TxCpltCallback:00000000 HAL_UART_TxCpltCallback
     /tmp/ccpEzoQP.s:451    .text.HAL_UART_TxCpltCallback:00000070 $d
     /tmp/ccpEzoQP.s:457    .text.vSerialTaskSendQueueBuf:00000000 $t
     /tmp/ccpEzoQP.s:462    .text.vSerialTaskSendQueueBuf:00000000 vSerialTaskSendQueueBuf
     /tmp/ccpEzoQP.s:505    .text.vSerialTaskSendQueueBuf:00000024 $d
     /tmp/ccpEzoQP.s:517    .bss.pbhd:00000000 pbhd
     /tmp/ccpEzoQP.s:524    .bss.SerialTaskHandle:00000000 SerialTaskHandle
     /tmp/ccpEzoQP.s:513    .bss.pbhd:00000000 $d
     /tmp/ccpEzoQP.s:520    .bss.SerialTaskHandle:00000000 $d
     /tmp/ccpEzoQP.s:527    .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueGenericReceive
xQueueGenericSend
HAL_UART_Transmit_IT
HAL_UART_Transmit_DMA
vPortEnterCritical
calloc
vPortExitCritical
xTaskCreate
xQueueGenericCreate
xQueueGiveFromISR
osDelay
